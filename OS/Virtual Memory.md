### 가상 메모리 

> **1. 연속 메모리 할당**
> 
> - 프로세스에 연속적인 메모리 공간을 할당하는 방식을 **연속 메모리 할당** 방식이라고 한다.
> - **스와핑**
>     - 메모리에 적재된 프로세스 중에는 현재 실행되지 않는 프로세스가 있을 수 있다.
>     이러한 프로세스들은 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 **메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑**이라고 한다.
>     - 쫓겨나는 보조기억장치의 일부 영역을 **스왑 영역**이라고 한다.
>     - 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 **스왑 아웃,** 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 **스왑인**이라고 한다.
>     - 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.
>         - UNIX와 Linux, macOS에서는 free, top 등 명령어를 통해 스왑 영역의 크기를 확인할 수 있다.
> - **메모리 할당**
>     - 프로세스는 메모리 내의 빈 공간에 적재되어야 한다.
>     - 대표적으로 최초 적합, 최적 적합, 최악 적합 세가지 방식이 있다.
>         1. **최초 적합**
>             - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 빈 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
>         2. **최적 적합**
>             - 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.
>         3. **최악 적합**
>             - 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.
> - **외부 단편화**
>     - 연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있다.
>     - 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이 현상을 외부 단편화라고 한다.
>     - **외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 압축하는 방법**이 있다.

> **2. 페이징을 통한 가상 메모리 관리**
> 
> - **가상 메모리**는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
> - **가상 메모리 관리 기법**에는 크게 **페이징과 세그멘테이션**이 있다.
> - **페이징**
>     - 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
>     - **페이징 시스템에서 스왑 아웃은 페이지 아웃, 스왑인은 페이지인으로 불린다.**
> - **페이지 테이블**
>     - 페이징 시스템은 프로세스가 물리 주소에 불연속적으로 배치되더라도 **논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용**한다.
>     - 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표이다.
>     - 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 된다.
>     - 페이징은 외부 단편화 문제를 해결할 수 있지만, **내부 단편화**라는 문제를 야기할 수 있다.
>     - 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다.
>     - **페이지 테이블 베이스 레지스터**는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
>     - 페이지 테이블을 메모리에 두면 **메모리 접근 시간이 두 배로 늘어나는 문제**가 발생할 수 있다.
>         - 메모리에 있는 페이지 테이블을 보기 위해 한번, 알게 된 프레임에 접근하기 위해 한번 이렇게 총 두번의 접근이 필요하기 때문이다.
>         - CPU 곁에 **TLB**라는 페이지 테이블의 캐시 메모리를 두는 방법으로 해결할 수 있다.
>         - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB 히트**라고 한다.
>         - 만일 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근할 수 밖에 없는 것을 **TLB 미스**라고 한다.
> - **페이징에서의 주소 변환**
>     - 특정 주소에 접근하기 위해서는
>         1. **어떤 페이지 혹은 프레임에 접근하고 싶은지**
>         2. **접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지**
>     - 위 두 가지 정보가 필요하다.
>     - 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호**와 **변위**로 이루어져있다.
>     - **논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소 <프레임 번호, 변위>로 변환된다.**
> - **페이지 테이블 엔트리**
>     - 페이지 테이블의 각 엔트리, 즉 페이지 테이블의 각각의 행들을 **페이지 테이블 엔트리**라고 한다.
>     - **유효 비트**
>         - 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
>         - **CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 페이지 폴트라는 예외가 발생한다.**
>     - **보호 비트**
>         - 페이지 보호 기능을 위해 존재하는 비트이다.
>         - 읽기를 나타내는 r, 쓰기를 나타내는 w, 실행을 나타내는 x의 조합으로 읽기 쓰기, 실행하기 권한의 조합을 나타낼 수 있다.
>     - **참조 비트**
>         - CPU가 페이지에 접근한 적이 있는지 여부를 나타낸다.
>     - **수정 비트**
>         - 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
>         - 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지, 할 필요가 없는지 판단하기 위해 존재한다.
>         - 수정된 적이 있는 페이지가 스왑 아웃 될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가되어야 한다.
> - **페이징 - 쓰기 시 복사**
>     - 프로세스 간 페이지를 공유하는 사례, **부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 순간 해당 페이지가 별도의 공간으로 복제되는 것**을 말한다.
>     - 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키게 된다.
> - **계층적 페이징**
>     - 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법, 여러 단계의 페이지를 둔다는 점에서 다단계 페이지 테이블 기법이라고도 불린다.
>     - 바깥 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한 페이지 테이블 엔트리를 가리키고, 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 **페이지 테이블의 페이지 번호를 가리키게 된다.**

> **3. 페이지 교체와 프레임 할당**
> 
> - **요구 페이징**
>     - 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 **필요한 페이지만을 메모리에 적재하는 기법**을 요구 페이징이라고 한다.
>     - **순수 요구 페이징 기법**
>         - 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어지는 것을 말한다.
> - **페이지 교체 알고리즘**
>     - 일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다.
>     - **페이지 교체 알고리즘을 제대로 이해하기 위해서는 페이지 폴트 횟수를 알 수 있어야 한다.**
>         - 페이지 폴트 횟수는 **페이지 참조열**을 통해 알 수 있다.
>         - 페이지 참조열은 CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지 열을 의미한다.
>         - 연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문이다.
>     - **FIFO 페이지 교체 알고리즘**
>         - 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
>     - **최적 페이지 교체 알고리즘**
>         - 최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다.
>         - 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적이다.
>         - 최적 페이지 교체 알고리즘은 이름 그대로 가장 낮은 페이지 폴트율을 보장하는 알고리즘이다.
>     - **LRU 페이지 교체 알고리즘**
>         - 사용되지 않은 페이지를 교체하는 알고리즘을 말한다.
>         - 최근에 사용되지 않은 페이지는 앞으로 사용되지 않을 것이라는 아이디어를 토대로 만들어진 알고리즘이다.
> - **스래싱과 프레임 할당**
>     - 프로세스가 **실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제**를 스래싱이라고 한다.
>     - 메모리에서 동시 실행되는 프로세스의 수를 **멀티프로그래밍의 정도**라고 한다.
>     - 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않기 때문이다.
>     - 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠 주는 방식을 **비례 할당**이라고 한다.
>     - 프로세스를 실행하는 과정에서 백분할 프레임을 결정하는 방식에는 크게 **작업 집합 모델**을 사용하는 방식과 **페이지 폴트 빈도**를 사용하는 방식이 있다.
>         - 실행 중인 프로세스가 일정 시간동안 참조한 페이지의 집합을 **작업 집합**이라고 한다.
>         - **페이지 폴트 기반 프레임 할당 방식**은 페이지 폴트율에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당하는 방식이다.