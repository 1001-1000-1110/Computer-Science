### CPU 스케줄링
 
> **1. CPU 스케줄링 개요**
> 
> - **운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것**을 **CPU 스케줄링**이라고 한다.
> - **프로세스 우선 순위**
>     - 프로세스마다 우선순위가 다르기 때문에 순서대로 CPU를 이용하게 하는 것은 좋은 방법이 아니다.
>     - **입출력 집중 프로세스**
>         - 입출력 작업이 많은 프로세스
>     - **CPU 집중 프로세스**
>         - CPU 작업이 많은 프로세스
>     - **입출력 집중 프로세스**는 실행 상태보다는 **입출력을 위한 대기 상태**에 더 많이 머무르게 된다.
>     - 반대로 **CPU 집중 프로세스**는 대기 상태보다는 **실행 상태**에 더 많이 머무르게 된다.
>     - **CPU 버스트와 입출력 버스트**
>         - **CPU를 이용하는 작업을 CPU 버스트, 입출력장치를 기다리는 작업을 입출력 버스트**라고 한다.
>         - 입출력 집중 프로세스는 입출력 버스트가 많은 프로세스, CPU 집중 프로세스는 CPU 버스트가 많은 프로세스라고 정의할 수 있다.
>     - 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것 X → 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적이다.
>     - **상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위를 부여한다.**
> - **스케줄링 큐**
>     - **CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄 세운다.**
>     - 운영체제는 이 **줄**을 **스케줄링 큐로 구현하고 관리**한다.
>     - 운영체제가 관리하는 대부분의 자원은 **큐로 관리**된다.
>     - **준비 큐(Ready Queue)는 CPU가 이용하고 싶은 프로세스들이 서는 줄**을 의미하고, **대기 큐(Waiting Queue)는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄**을 의미한다.
>     - 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다.
>     - 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그 중 우선순위가 높은 프로세스를 먼저 실행한다.
>     - 대기 상태에 있는 프로세스도 마찬가지로 같은 장치를 요구한 프로세스들은 같은 대기 큐에서 기달니다.
>     - 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다. 해당 PCB는 준비 큐로 이동한다.
>     - 프로세스 상태 다이어그램
>         <img src = 'image/Process Status Diagram-2.jpg' alt = 'Process Status Diagram-2' width='500' height='300'>
>         
> - **선점형과 비선점형 스케줄링**
>     - **선점형 스케줄링**
>         - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 **자원을 강제로 빼앗아 다른 프로세스에 할당**할 수 있는 스케줄링 방식을 말한다.
>         - 하나의 프로세스가 자원을 독점할 수 없는 스케줄링 방식이다.
>         - 선점형 스케줄링은 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
>     - **비선점형 스케줄링**
>         - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 말한다.
>         - 비선점형 스케줄링은 하나의 프로세스가 자원을 독점할 수 있는 스케줄링 방식이다.
>         - 비선점형 스케줄링은 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수 밖에 없다.

> **2. CPU 스케줄링 알고리즘**
> 
> - CPU 스케줄링 알고리즘의 종류는 매우 다양하고 운영체제마다 서로 다른 스케줄링 알고리즘을 사용하고 있다.
> - **스케줄링 알고리즘의 종류**
>     - **선입 선처리 스케줄링 / FCFS 스케줄링**
>         - **단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리**하는 **비선점형 스케줄링** 방식이다.
>         - CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 스케줄링 방식이다.
>         - 호위 효과 / Convoy Effect
>     - **최단 작업 우선 스케줄링 / SJF 스케줄링**
>         - 준비 큐에 삽입된 프로세스들 중 **CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행**하는 스케줄링 방식이다.
>         - **기본적으로 비선형 스케줄링 알고리즘**으로 구분되지만 **선점형으로 구현될 수도 있다.**
>             - **선점형 최단 작업 우선 스케줄링 == 최소 잔여 우선 스케줄링**
>     - **라운드 로빈 스케줄링**
>         - **선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링** 방식이다.
>         - **타임 슬라이스**란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.
>         - 라운드 로빈 스케줄링은 정해진 타임 슬라이스만큼의 시간 동안 돌아가면 CPU를 이용하는 **선점형 스케줄링**이다.
>     - **최소 잔여 시간 우선 스케줄링 / SRT 스케줄링**
>         - **최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링** 방식이다.
>         - 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택 된다.
>     - **우선 순위 스케줄링** 
>         - 우선 순위 스케줄링은 **프로세스들에 우선순위를 부여**하고, **가장 높은 우선 순위를 가진 프로세스부터 실행**하는 스케줄링 알고리즘이다.
>         - 우선 순위가 낮은 프로세스는 **준비 큐에 먼저 삽입 되었음에도 불구**하고, 우선 순위가 높은 프로세스들에 의해 **실행이 계속 연기**될 수 잇다. → **기아 현상**
>         - 기아 현상을 방지하기 위한 기법 → **에이징**
>             - 에이징은 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.
>     - **다단계 큐 스케줄링**
>         - 다단계 큐 스케줄링은 **우선순위 별로 준비 큐를 여러 개 사용하는 스케줄링** 방식이다.
>         - 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.
>     - **다단계 피드백 큐 스케줄링**
>         - 다단계 피드백 큐 스케줄링에서는 **프로세스들이 큐 사이를 이동할 수 있다.**
>         - 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다. → 기아 현상 발생
>         - 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정시간동안 실행된다.
>         - 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선 순위에 삽입되어 실행된다. → 결국 CPU를 오래 사용해야 하는 프로세스는 점차 순위가 낮아진다.
>         - CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 우선순위가 높은 큐에 실행이 끝난다.
>         - **즉, 다단계 피드백 큐 스케줄링 알고리즘은 어떤 프로세스의 CPU 이용시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘이다.**
