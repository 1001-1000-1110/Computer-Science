## 빠른 CPU를 위한 설계 기법

- 클럭
    1. 컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직인다.
    2. CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어를 실행한다.
    - 클럭 속도는 헤르츠 단위로 측정, 1초에 클럭이 몇번 반복되는지
    - 클럭속도는 CPU의 속도 단위로 간주되기도 함
    - 클럭 속도가 높은 CPU는 빠르게 동작
    - 고성능을 요하는 순간 순간적으로 클럭 속도는 올라가고 그러지 않을 때는 유연하게 클럭 속도가 낮아진다
    
    → 클럭속도를 무작정 높이면 발열 문제가 심각해진다..!
    
    → 코어와 스레드 수를 늘려보자~
    
- 코어와 멀티코어
    
    - 코어 : 명령어를 실행하는 부품
    - CPU : 명령어를 실행하는 부품을 여러개 포함하는 부품
    - 멀티코어(멀티코어 프로세서) : 코어를 여러개 포함하고 있는 CPU
    - 멀티코어의 처리속도가 단일코어보다 빠르다
    
    → 하지만 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않는다
    
- 스레드와 멀티 스레드
    
    스레드에는 CPU에서 사용하는 하드웨어적 스레드와 프로그램에서 사용되는 소프트웨어 스레드가 있다.
    
    - 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
        - 멀티스레드 프로세서(멀티스레드 CPU) : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
            
            하나의 코어 언의 스레드들이 빠르게 번갈아가면서 처리 → 동시에 실행되는 거처럼 보임
            
        
    - 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위
        
        
        → 프로그래밍 언어를 이용해 소프트웨어적 스레드를 만들 수 있음
        
    
    > 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십개 실행할 수 있다. 1코어 1스레드 CPU로도 프로그램의 여러 부분을 동시에 실행 가능
    > 
    > 
    > → 번갈아가면서 조금씩 실행 → 동시에 실행하는 것 처럼 보임
    > 
    - 멀티 스레드 프로세서
        
        하나의 코어로 여러 명령어를 동시에 처리하는 CPU
        
        - 레지스터 세트(하나의 명령어를 실행하기 위해 꼭 필요한 레지스터들의 모임)을 여러개 갖는 것

## 명령어 병렬 처리 기법

빠른 CPU를 만들기 위해서는 CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요하다.

명령어 병렬 처리 기법 : 명령어를 동시에 처리하여 CPU가 한시도 쉬지 않고 작동시키는 기법

1. 명령어 파이프라인
    - 명령어 처리 과정
        1. 인출(Instruction Fetch)
        2. 해석(Instruction Decode)
        3. 실행(Execute Instruction)
        4. 결과 저장(Write Back)
    
    → 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다
    
    
    - 파이프라이닝이 높은 성능을 가져오기는 하지만 특정 상황에서는 성능 향상에 실패하는 경우도 있다 → 파이프 라인 위험
        - 데이터 위험
            
            의존적인 두 명령어를 무작정 동시에 실행하려고할 경우
            
        - 제어 위험
            
            프로그램 카운터의 갑작스러운 변화에 의해 발생
            
            → PC는 기본적으로 현재 실행 중인 명령어의 다음 주소로 갱신되는데, PC의 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리중이었던 명령들은 무쓸모
            
            > **분기예측**
            > 
            > 
            > 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술
            > 
        - 구조적 위험(자원 위험)
            
            서로다른 명령어가 동시에 ALU, 레지스터와 같은 CPU부품을 사용하려고 하는 경우
            
2. 슈퍼스칼라
    
    CPU 내부에 여러 개의 명령어 파이프 라인을 포함한 구조
    
    - 멀티스레드 프로세서는 한번에 여러 명령어를 인출하고 해석하고 실행할 수 있기 때문에 슈퍼스칼라 구조 사용 가능
    - 여러개의 파이프라인을 이용하면 파이프라인 위험성 증가
3. 비순차적 명령어 처리(OoOE)
    
    
    명령어들을 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법
    

## CISC와 RISC

CPU가 파이프 라이닝과 슈퍼스칼라 기법을 효과적으로 활용하기 위해선 명령어가 파이프라이닝 하기 쉽게 생겨야한다.

- 명령어 집합 구조(ISA): CPU가 이해할 수 있는 명령어들의 모음
    
    CISC, RISC
    
    
    - 인텔의 노트북 속 CPU는 x86 ISA나 x86-64 ISA를 이해하고 아이폰 속 CPU는 ARM ISA를 이해한다
    - ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻
    - 같은 소스코드로 만들어진 같은 프로그램이라고 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어와 어셈블리어도 달라진다.
    - 동일한 컴파일러를 이용해도 CPU에 따라 명령어가 달라진다.
    - ISA가 다르면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많이 것들이 달라짐
    - ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속
- CISC(Complex Instruction Set Computer)
    - 복잡한 명령어 집합을 활용하는 컴퓨터
    - x86, x86-64
    - 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용
    - 상대적으로 적은 수의 명령어로도 프로그램 실행 가능
    - 메모리 공간 절약 O
    - 실제 대다수의 복잡한 명령어는 사용 빈도가 낮음
    - 명령어의 크기와 실행되기 까지의 시간이 일정하지 않고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로함
        
        → 명령어 규격화의 어려움
        
        → 명령어 파이프라인을 구현하는데에 큰 걸림돌
        
- RISC(Reduced Instruction Set Computer)
    - 명령어의 종류가 적음
    - 짧고 규격화된 명령어 → 많은 명령어로 프로그램 작동
    - 메모리에 직접 접근하는 명령어를 load, store 두개로 제한
        
        → CISC보다 주소 지정 방식의 종류가 적음
        
    - 레지스터를 적극적으로 활용하여 레지스터를 이용하는 연산이 많고 범용 레지스터 개수도 많음
    - 되도록이면 1클럭 내외로 실행되는 **고정 길이 명령어**를 활용
        
        → 명령어 파이프 라이닝에 최적화
