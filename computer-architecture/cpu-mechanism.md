## ALU와 제어장치

- ALU
    
    - ALU가 받아들이는 정보
        
        ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.
        
    - ALU가 내보내는 정보
        
        연상을 수행한 결과는 특정 숫자나 문자, 메모리 주소가 될 수 있다. 이 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다. ALU는 계산 결과와 더불어 플래그를 내보낸다. 여기서 플래그는 연산 결과에 대한 추가적인 상태 정보이다. 이 플래그들은 플래그 레지스터에 저장된다. 
        
- 제어장치
    
    제어신호를 내보내고, 명령어를 해석하는 부품. 제어신호는 컴퓨터의 부품들을 관리하고 작동시키기 위한 일종의 전기신호
    
    - 제어장치가 받아들이는 정보
        1. 클럭신호
            
            클럭 : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위로 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동
            
        2. 해석해야할 명령어
            
            cpu가 해석해야할 명령어는 명령어 레지스터에 저장된다. 제어장치는 이 명령어를 받아들이고 해석한 뒤 제어신호를 발생시킨다.
            
        3. 플래그 값
            
            플래그 값을 받아들이고 이를 참고하여 제어신호를 발생시킴
            
        4. 제어버스로 전달된 제어신호
            
            제어신호는 CPU뿐만 아니라 CPU외부 장치도 발생시킬 수 있고 제어장치는 제어버스를 통해 외부로부터 전달된 제어신호를 받아들이기도 한다.
            
    - 제어장치가 내보내는 정보
        1. CPU외부에 전달하는 제어 신호
            
            메모리에 전달, 입출력장치에 전달(보조기억장치 포함)
            
        2. CPU내부에 전달하는 제어신호
            
            ALU에 전달, 레지스터에 전달
            

## 레지스터

프로그램 속 명령어와 데이터는 실행 전/후로 반드시 레지스터에 저장된다. CPU안에는 다양한 레지스터들이 있고 각각 다른 역할을 가지고 있다. 

1. 프로그램 카운터(PC)
    
    메모리에서 읽어 들일 명령어의 주소를 저장하는 레지스터(명령어 포인터:IP라고도 부름). PC는 꾸준히 증가하며 프로그램을 차례대로 실행한다.
    
2. 명령어 레지스터(IR)
    
    해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
    
    → 제어 장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어신호를 발생
    
3. 메모리 주소 레지스터(MAR)
    
    메모리의 주소를 저장하는 레지스터로, CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보내기 전 반드시 메모리 주소 레지스터를 거친다.
    
4. 메모리 버퍼 레지스터(MBR)
    
    메모리와 주고 받을 값을 저장하는 레지스터로, 메모리에 쓸 데이터나 메모리로부터 전달 받은 데이터를 메모리 버퍼 레지스터를 거친다. 데이터를 데이터 버스로 보내기 전 반드시 메모리 버퍼 레지스터를 거친다.
    
- 동작 예시
    
    가정 :  1000~1500번지에 실행할 프로그램의 명령어들이 저장되어있는 상황
    
    PC에 1000이 저장 → 메모리 주소 레지스터에 1000이 저장 → ‘메모리 읽기’ 제어신호와 메모리 주소 레지스터 값이 각각 제어스와 주소 버스를 통해 메모리로 보내짐
    
    → 메모리 1000번지에 저장된 값이 데이터 버스를 통해 메모리 버퍼 레지스터로 전달 →  PC 증가 (다음 명령어 읽어 들일 준비 완) → 메모리 버퍼 레지스터의 값은 명령어 레지스터로 이동 → 제어장치가 명령어 레지스터에 저장된 명령어를 해석하고 제어신호 발생
    
1. 범용 레지스터
    
    다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터. 데이터와 주소를 모두 저장 가능
    
2. 플래그 레지스터
    
    연산 결과 또는 CPU상태에 대한 부가적인 정보를 저장하는 레지스터
    
3. 스택 포인터
    
    스택의 꼭대기를 가리키는 레지스터
    
4. 베이스 레지스터
    
    기준 주소가 저장된 레지스터
    

## 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름
    
    1. 인출 사이클 : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
    2. 실행 사이클 : CPU로 가져온 명령어를 실행하는 단계, 제어 장치가 명령어 레지스터에 담긴 값을 해석하고 제어신호를 발생시키는 단계
    3. 간접 사이클 : 명령어를 실행하기 위해 메모리에 재접근하는 단계 ex) 간접주소지정방식
- 인터럽트 : CPU의 정상적인 작업을 방해하는 신호
    - 동기 인터럽트 (예외)
        
        CPU에 의해 발생하는 인터럽트로, CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 경우 (프로그래밍상의 오류와 같은 예외적인 상황)
        
    - 비동기 인터럽트 (하드웨어 인터럽트)
        
        입출력 장치에 의해 발생하는 인터럽트
        
        - 프린터와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력 장치가 CPU에 완료 알림(인터럽트)를 보냄
            
            → 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없음
            
        - 키보드, 마우스와 같은 입출력 장치가 어떤 입력을 받았을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)를 보냄
        - 하드웨어 인터럽트 처리 순서
            1. 입출력 장치가 CPU에 **인터럽트 신호 요청**
                
                cpu에게 지금 끼어들어도 되는지 물어봄
                
            2. CPU는 실행 사이클이 끝나고 명령어 인출 전, 항상 인터럽트 여부를 확인
            3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 인터럽트 수신 여부 확인
                
                하드웨어 인터럽트를 받아들일지 무시할 지 결정하는 플래그 (무시할 수 없는 인터럽트 요청도 있음)
                
            4. 인터럽트 수신이 가능하다면 CPU는 지금까지의 작업을 백업
                
                프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업
                
            5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
                
                - 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 프로그램으로 메모리에는 여러개의 인터럽트 서비스 루틴이 저장되어 있음
                - 인터럽트 벡터 : 인터럽트 서비스 루틴을 식별하기 위한 정보로 인터럽트 서비스 루틴의 시작 주소가 들어있음
            6. 인터럽트 서비스 루틴 실행이 끝난 후 백업해둔 작업을 복구하여 재개
                
                스택에 저장해 둔 값을 다시 불러온 뒤 이전까지 수행하던 작업을 재개
                
    
    > **예외의 종류 (동기 인터럽트)**
    > 
    > 
    > - 폴트 : 예외를 처리한 직후 예외가 발생한 명령어부터 실행하는 예외
    >     
    >     ex) 명령어를 실행하기 위해 필요한 데이터가 메모리가 아닌 보조기억장치에 있을 경우
    >     
    > - 트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
    >     
    >     ex) 디버깅
    >     
    > - 중단 : CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 경우
    > - 소프트웨어 인터럽트 : 시스템 호출이 발생했을 경우
