## 소스코드와 명령어

- 모든 **소스코드**는 컴퓨터 내부에서 **명령어**로 변환된다.
- 고급언어 : 사람을 위한 언어
    - 대부분의 프로그래밍 언어
- 저급언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
    - 기계어
        
        0과 1의 명령어 비트로 이루어진 언어
        
    - 어셈블리어
        
        기계어를 읽기 편한 형태로 번역한 언어
        
- 컴파일 언어와 인터프리터 언어
    
    고급언어가 저급언어로 변환하는 방식 : 컴파일 방식, 인터프리트 방식
    
    - 컴파일 언어
        
        컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급언어 ex) C
        
        - 컴파일 : 컴파일 언어로 작성된 소스 코드가 저급언어로 변환되는 과정 → 소스코드가 실행 가능한 코드인지 확인하며 저듭 언어로 컴파일
        - 컴파일러 : 컴파일을 수행해주는 도구
        - 목적코드 : 컴파일 언어가 컴파일러를 통해 저급 언어로 변환된 코드
        - 소스 코드 컴파일 중 오류가 발생하면 소스코드 전체가 실행되지 않음
    - 인터프리터 언어
        
        인터프리터에 의해 소스 코드가 한줄씩 실행되는 고급언어 ex) Python
        
        - 인터프리터 : 소스 코드를 한줄씩 저급 언어로 변환하여 실행해 주는 도구
        - 소스코드 N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행

> 일반적으로 인터프리터 언어는 컴파일 언어보다 느리다. 컴파일의 결과물인 목적코드는 컴퓨터가 이해하고 실행할 수 있는 저급언어인 반면, 인터프리터 언어는 소스코드 마지막에 이를 때까지 한줄씩 저급 언어로 해석하며 실행하기 때문이다.
> 

<aside>
💡 java는 컴파일 언어? 인터프리터 언어? 

컴파일 언어와 인터프리터 언어 간의 경계가 모호한 경우가 많다. 예를 들어 java같은 경우 자바 컴파일러에 의해 소스코드(.java)가 자바 바이트코드(.class)로 컴파일 되고 자바 인터프리터(by JVM)에 의해 기계어로 변환되며 실행된다. 즉 자바 소스코드가 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행한다.

</aside>

<aside>
💡 목적파일 VS 실행파일

목적코드(.o)가 실행파일(.exe)이 되기 위해서는 링킹이라는 작업을 거쳐야 한다. 여기서 링킹은 예를 들어 main.o에 없는 외부 기능들을 연결짓는 작업이다.

</aside>
```
소스파일 → (컴파일) → 목적파일 → (링킹) → 실행파일
```
## 명령어의 구조

명령어는 연산코드와 오퍼랜드로 구성된다.

- 연산코드 : 명령어가 수행할 연산 ex) 더해라, 빼라, 저장해라
    - 연산코드의 종류
        1. 데이터 전송
        2. 산술/논리 연산
        3. 제어 흐름 변경
        4. 입출력 제어
        - 연산코드 예시
            
- 오퍼랜드 : 연산에 사용할 데이터 또는 데이터가 저장된 위치
    - 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다.
    - 주로 메모리의 주소나 레스터스 이름이 담기기 때문에 주소필드라고도 한다.
    - 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
    - 1-주소 명령어 : 오퍼랜드가 하나인 명령어
- 주소 지정 방식
    
    > 명령어의 길이는 정해져 있기 때문에 오퍼랜드 필드 안에 데이터가 아닌 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간 만큼 커진다.
    > 
    - 유효주소 : 연산의 대상이 되는 데이터가 저장된 위치
    - 주소 지정 방식 : 유효주소를 찾는 방법
    1. 즉시 주소 지정 방식
        
        연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만, 연산에 사용할 데이터를 주소로 부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들보다 빠르다.
        
    2. 직접 주소 지정 방식
        
        오퍼랜드 필드에 유효 주소에 직접적으로 명시하는 방식. 메모리의 크기만큼 데이터 크기가 보장되어서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 커졌지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었음. → 표현할 수 있는 유효 주소에 제한이 생길 수 있음.
        
    3. 간접 주소 지정 방식
        
        유효 주소의 주소를 오퍼랜드에 명시. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 넓어짐 → 두번의 메모리 접근이 필요하기 때문에 다른 주소 지정 방식들보다 일반적으로 느린 방식
        
    4. 레지스터 주소 지정 방식
        
        직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법. 일반적으로 CPU외부에 있는 메모리에 접근하는 것 보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다(명령어를 해석하고 실행하는 것이 CPU안에 있는 제어장치 이기 때문인가..?). 따라서 레지스터 주소 지정 방식은 직접 주소방식보다 빠르게 데이터에 접근할 수 있음.
        
    5. 레지스터 간접 주소 지정 방식
        
        연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효주소)를 저장한 레지스터 이름을 오퍼랜드 필드에 명시하는 방법. 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한번으로 줄어든다는 차이가 있다. 즉 간잡 주소 지정 방식은 ‘메모리 → 메모리 → 데이터’로 두번 메모리에 접근하지만 레지스터 간접 주소 지정 방식은 ‘레지스터 → 메모리 → 데이터’로 접근하여 데이터에 더 빠르게 접근할 수 있다. (메모리 접근 속도 < 레지스터 접근 속도)
        
    6. 스택 주소 지정 방식
        
        스택과 **스택 포인터**를 이용한 주소 지정 방식
        
    7. 변위 주소 지정 방식
        
        오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효주소를 얻어내는 방식으로 변위 주소 지정 방식을 사용하는 명령어에는 연산코드 필드, 레지스터 필드, 오퍼랜드 필드가 존재. 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는 지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉨
        
        - 상대 주소 지정 방식
            
            오퍼랜드와 PC값을 더하여 유효주소를 얻는 방식으로 특정 주소의 코드를 실행할 때 사용된다.
            
        - 베이스 레지스터 주소 방식
            
            오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식으로 베이스 레지스터는 ‘기준주소’, 오퍼랜드는 ‘기준 주소로 부터 떨어진 거리’로서의 역할을 한다. 
            
        

> **스택과 큐**
> 
> 
> 스택 : 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입 선출, LIFO)
> 
> 큐 : 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출, FIFO)
>
