# 트랜잭션
트랜잭션(transaction)은 작업 하나를 수행하는데 필요한 데이터베이스의 연산들을 모아놓은 것으로, 데이터 베이스의 논리적인 작업의 단위이다. 장애가 발생했을 때 데이터를 복구하는 작업의 단위도 된다.

## 트랜잭션
- 트랜잭션의 특성(ACID)  
트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성이 보장되려면 아래의 네가지 특성을 만족해야한다.
  - 원자성(atomicity)  
    트랙잭션을 구성하는 연산들이 모두 정상적을 실행되거나 하나도 실행되지 않아야 한다.
  - 일관성(consistency)  
    트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 한다.  
    ex) a 에서 b로 입금 전, 후 a + b의 계좌의 값이 동일해야 한다.
  - 격리성(고립성)(isolation)  
    트랙잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음을 의미한다.
  - 지속성(영속성)(durability)  
    트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다. 즉, 시스템 장애가 발생하더라도 트랙잭션 작업 결과는 데이터베이스에 그대로 남아 있어야 한다.
  

- 트랜잭션의 연산
  - commit연산  
    트랜잭션이 성공적으로 수행되었음을 선언하는 연산(작업 완료)
  - rollback연산  
    트랜잭션을 수행하는 데 실패했음을 선언하는 연산(작업 취소)
  

- 트랜잭션의 상태
  - 활동상태(active)  
  트랜잭션이 수행되기 시작하여 현재 수행중인 상태
  - 부분완료상태(partially committed)  
  트랜잭션의 마지막 연산이 실행된 직후의 상태로, 트랜잭션의 모든 연상을 처리한 상태이다. 수행된 최종 결과를 데이터베이스에 아직 반영하지 않은 상태이다.
  - 완료상태(committed)
  트랙잭션이 성공적으로 완료되어 commit연산을 실행한 상태로 최종 결과를 데이터베이스에 반영하고, 테이터베이스가 새로운 일관상태가 되면 트랙잭션이 종료된다.
  - 철회상태(aborted)  
  트랜잭션을 수행하는 데 실패하여 rollback연산을 실행한 상태이다. 철회상태가 된 원인이 트랜잭션의 논리적 오류인 경우 철회된 트랜잭션을 폐기하고, 소프트웨어나 하드웨어의 이상인 경우에는 철회된 트랜잭션을 다시 시작한다.

## 장애와 회복
- 장애: 시스템이 제대로 동작하지 않는 상태
- 회복: 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것

- 데이터베이스의 복사본을 만드는 방법
  - 덤프(dump): 데이터베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법
  - 로그(log): 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법

- 회복을 위한 연산
  - redo(재실행)   
  가장 최근에 저장한 데이터베이스의 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경연산을 재실행하여 장애가 발생하기 직전의 데이터베이스로 복구하는 것이다.
  - undo(취소)  
  로그를 이용해 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래 상태로 복구하는 것이다.

- 회복 기법의 유형
  - 로그 회복 기법: 로그를 이용한 회복 기법이다.
  - 검사 시점 회복 기법: 검사 시점을 이용한 회복기법이다.
  - 미디어 회복 기법: 데이터베이스 덤프(복사본)을 이용한 회복기법이다.

- 로그 회복 기법  
  로그를 이용한 회복 기법으로, 즉시 갱신 회복과 지연 갱신 회복이 있다.
  - 즉시 갱신 회복
    - 트랜잭션을 수행 중에 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영한다.
    - 트랜잭션에서 데이터베이스 변경 연산이 실행되었을 때 로그 파일에 로그 레코드를 먼저 기록한 후 데이터베이스에 변경 연산을 반영한다.
    - 트랜잭션이 완료되기 전에 장애가 발생하면 -> undo 연산 실행
    - 트랜잭션이 완료된 후에 장애가 발생하면 -> redo 연산 실행
  - 지연 갱신 회복
    - 트랜잭션이 부분 완료되면 데이터 변경 연산의 결과를 데이터베이스에 한번에 반영한다.
    - 트랜잭션 수행중 데이터 변경 연산의 결과를 로그파일에 기록해두다가, 트랜잭션이 부분완료된 후에 기록된 로그의 내용을 데이터베이스에 한번에 반영한다.
    - undo연산이 필요하지 않아(트랜잭션이 완료되기 전 장애 발생시 결과를 반영하지 않으면 된다), 트랜잭션이 완료된 후 장애가 발생하면 redo연산을 사용한다.

- 검사 시점 회복 기법
  - 일정한 시간 간격으로 검사 시점(check point)를 만들어둔다. 그리고 장애가 발생시, 가장 최근 검사 시점 이후 트랜 잭션에만 회복 작업(즉시 갱신 회복기법, 지연갱신 회복 기법 )을 수행한다.
  - 불필요한 회복작업을 수행하지 않아 빠르게 회복할 수 있다.

- 미디어 회복 기법
  - 데이터 베이스는 비휘발성 저장 장치인 디스크에 저장된다. 이러한 디스크에 발생할 수 있는 장애에 대비한 회복기법이다.
  - 일정 주기마다 다른 저장장치에 데이텁베이스의 내용을 저장한다. 디스크에 장애가 발생하면, 최근에 복사해둔 덤프를 이용해 장애 발생전으로 북구한 뒤 redo연산을 실행한다.
  - 비용과 시간이 많이 소모되며, cpu가 낭비된다.

## 병행 제어
- 병행 수행: 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러개의 트랜잭션이 동시에 수행되는 것
- 병행 제어: 병행 수행으로 같은 데이터에 접근할 경우, 문제가 발생하지 않고 정확한 수행결과를 얻을 수 있도록 제어하는 것

- 병행 수행의 문제
  - 갱신 분실(lost update) : 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것
  - 모순성(inconsistency) : 하나의 트랜잭션이 여러개의 데이터 변경 연산일 실행할 때 일관 성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생하는 것
  - 연쇄 복귀(cascading rollback): 장애가 발생한 트랜잭션이 rollback연산을 실행하기전에, 변경된 데이터를 가져가 사용하는 다른 트랜잭션이 수행을 완료해버리면 rollback연산을 실행할 수 없는 문제

- 트랜잭션의 스케줄
  - 직렬 스케줄: 인터리빙 방식을 사용하지 않고 트랜잭션별로 연산을 순차적으로 실행하는 스케줄
  - 비직렬 스케줄: 인터리빙 방식을 이용하여 트랜잭션들을 병행 수행 시키는것
  - 직렬 가능 스케줄: 직렬 스케줄과 동일한 정확한 결과를 생성하는 비직렬 스케줄

- 병행 제어 기법  
  여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능 성을 보장받기 위해 사용한다. 모든 트랜잭션들이 준수하면 직렬 가능성이 보장되는 규약을 정의하고 트랜잭션들이 이 규약을 따르도록 한다.

  - 로킹 기법  
    트랜 잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산으로 제어한다. 로킹 단위가 커질수록 병행성이 낮아지지만 제어가 쉽고, 로킹 단위가 작아질수록 제어가 어렵지만 병행성이 높아진다.
    - lock연산: 트랜잭션이 데이터에 대한 독점권을 요청하는 연산
    - unlock연산: 트랜잭션이 데이터에 대한 독점권을 반환하는 연산
  - 2단계 로킹 규약  
  트랜잭션이 lock과 unlock연산을 확장 단계와 축소 단계로 나뉘어 수행해야한다. 모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성을 보장 받는다.
    - 확장단계: 트랜잭션이 lock연산만 실행할 수 있고, unlock연산은 실행할 수 없는 단계
    - 축소단계: 트랜잭션이 unlock연산만 실행할 수 있고, lock연산은 실행할 수 없는 단계  
    이러한 2단계 로킹 규약을 준수하는 트랜잭션은 첫 번째 unlock연산을 실행하기 전에 필요한 모든 lock연산을 실행해야한다. 또한 `교착상태`가 발생할 수 있다.
  - 교착상태(deadlock)
    - 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock연산이 실행되기를 서로 기다리면서 수행을 중단하고 있는 상태