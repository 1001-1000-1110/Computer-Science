## CPU 스케줄링 개요

CPU 스케줄링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

### 프로세스 우선순위

우선순위가 높다는 것은 빨리 처리해야하는 프로세스. 상황과 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 운영체제는 프로세스마다 우선순위(in PCB)를 부여한다.

- 입출력 집중 프로세스(I/O bound process) : 입출력 작업(입출력 버스트)이 많은 프로세스
- CPU 집중 프로세스(CPU bound process) : CPU 작업(CPU 버스트)이 많은 프로세스

→ 입출력 작업할 시, 대기상태가 되기 때문에 입출력 집중 프로세스는 CPU 집중 프로세스보다 대기상태에 더 많이 머무르게된다. 따라서 입출력 집중 프로세스를 더 빨리 실행시켜 입출력장치를 끊임없이 작동시키고 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적이다.

→ 입출력 집중 프로세스는 어차피 CPU를 잠깐 쓰고 대기상태로 들어가니까 얘 먼저 처리한 후, CPU 집중 프로세스 실행해는게 이득

### 스케줄링 큐

PCB에 우선순위가 적혀있다고 해도 CPU가 매번 프로세스들의 PCB를 뒤적거리며 확인하는 것은 매우 비효율적 

→ 스케줄링 큐 : 프로세스들이 줄을 서서 기다리고 있는 큐. 자원을 기준으로 큐를 구분하여 프로세스들을 줄 세운다. 큐에 있는 프로세스 중 우선순위가 높은 프로세스를 먼저 실행시킨다.

- 준비 큐 (ready queue) : CPU를 이용하고 싶은 프로세스들이 서는 줄
- 대기 큐 (waiting queue) : 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
    
    같은 장치를 요구한 프로세스들은 같은 대기 큐에서 대기. 입출력이 완료 되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 해당 PCB를 찾아 준비 큐로 이동.
    
### 선점형과 비선점형 스케줄링

1번 프로세스가 CPU를 이용하고 있는데 갑자기 2번 프로세스가 지금 당장 CPU를 이용해야한다고 한다면?

1. 선점형 스케줄링
    
    그래, 너 먼저 해~
    
    프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 → 자원 독점 불가
    
    - 장점 : 프로세스의 자원 독점을 방지하고 프로세스들에 골고루 자원을 배분
    - 단점 : 문맥교환이 자주 발생하여 오버헤드 발생할 수 있음
2. 비선점형 스케줄링
    
    안 돼, 기다려!
    
    하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 대기상태로 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 → 자원 독점 가능
    
    - 장점 : 문백교환이 덜 발생하여 오버헤드 적음
    - 단점 : 먼저 사용하고 있는 프로세스를 무작정 기다려야함. 골고루 자원 사용 불가

## CPU 스케줄링 알고리즘

1. 선입 선처리 스케줄링(FCFS, First Come First Scheduling)
    
    준비큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식. 즉 먼저 준비 큐에 들어온 것부터 실행
    
    → 호위효과 : CPU 사용시간이 짧은 프로세스가 늦게들어왔다는 이유로 긴 시간을 기다리는 것
    
2. 최단 작업 우선 스케줄링(SJF, Shortest Job First Scheduling)
    
    CPU 사용시간이 짧은 프로세스를 먼저 실행하는 비선점형 스케줄링 방식. 호위효과 방지
    
3. 라운드 로빈 스케줄링(RR, round robin scheduling)
    
    선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식. 타입슬라이드란 프로세스가 CPU를 사용할 수 있는 정해진 시간. 준비큐에 먼저 들어온 프로세스부터 실행하되, 타입슬라이스만큼만 실행된 후, 프로세스가 다 완료되지 않았다면 다시 준비 큐의 맨 뒤에 삽입 → 문맥교환 발생
    
4. 최소 잔여 시간 우선 스케줄링(SRT, Shortest Remaining Time)
    
    최단 작업 우선 스케줄링에 라운드 로빈 알고리즘을 합친 스케줄링. 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 남아 있는 작업 시간이 가장 적은 프로세스 순으로 실행.
    
5. 우선순위 스케줄링(PS, Priority Scheduling)
    
    프로세스들에 우선순위를 부여하고 가장 높은 우선순위를 가진 프로세스부터 실행.
    
    → 기아현상(starvation) : 우선순위가 낮은 프로세스들이 우선순위가 높은 프로세스들에 의해 실행이 계속해서 연기되는 현상. 해결방법 : 에이징
    
    → 에이징(aging) : 오랫 동안 대기한 프로세스의 우선 순위를 점차 높여주는 방식. 우선 순위가 낮더라도 언젠가는 높은 우선순위가 된다.
    
6. 다단계 큐 스케줄링(multilevel queue scheduling)
    
    우선순위 별로 준비 큐를 여러개 사용하는 스케줄링 방식으로 우선순위가 높은 큐에 있는 프로세스들을 먼저 처리하고 우선 순위가 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리
    
    - 프로세스 유형별로 우선순위를 구분하여 실행 가능
    - 큐 별로 타임 슬라이스를 다르게 지정 가능
    - 큐마다 다른 스케줄링 알고리즘을 사용 가능
    
    프로세스가 큐 사이를 이동할 수 없다. 이러한 경우, 우선 순위가 낮은 프로세스는 계속 연기될 수 밖에 없게된다. → 기아현상 발생 가능성
    
7. 다단계 피드백 큐 스케줄링(multilevel feedback queue scheduling)
    
    프로세스들이 큐 사이를 이동할 수 있다. 가장 일반적인 CPU 스케줄링 알고리즘
    
    1. 새로 준비 상태가 된 프로세스는 우선순위가 가장 높은 큐에 삽입되고 타입슬라이스 동안 실행된다. 
        
    2. 프로세스가 다 완료되지 않았다면 다음 우선순위 큐에 삽입된다.
        
    3. 위 과정을 반복
    
    → CPU 집중 프로세스들은 자연스레 우선순위가 점점 낮아지고 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 완료된다. 낮은 우선순위에 너무 오래 기다리고 있는 프로세스들에 에이징 기법을 적용하여 기아 현상을 예방한다.
