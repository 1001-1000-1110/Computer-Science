### **CPU의 작동 원리**

> 1. **ALU와 제어장치** 
>     - **ALU**는 레지스터를 통해 피연산자를 받아들이고, 제어 장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.
>         - CPU가 메모리에 접근하는 속도 VS CPU가 레지스터에 접근하는 속도 → 레지스터가 훨씬 빠르다.
>         - ALU가 연산할 때마다 결과를 메모리에 저장하게 된다면 당연히 CPU는 메모리에 자주 접근하게 되고, CPU가 프로그램 실행속도를 늦추는 원인이 된다.
>         - 그렇기 때문에 ALU의 결과값을 메모리가 아닌 레지스터에 우선 저장하는 것이다.
>     - ALU는 계산과 더불어 **플래그**를 내보낸다.
>         - 연산 결과에 대한 **추가적인 상태 정보**를 플래그라고 한다.
>         - 플래그들은 **플래그 레지스터**라는 레지스터에 **저장**된다.
>         - 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황을 **오버플러우**라고 한다.
>     - **제어 장치**는 제어 신호를 내보내고, 명령어를 해석하는 부품이다.
>         - 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.
>     - **제어 장치가 받아들이는 정보**
>         1. 제어장치는 클럭 신호를 받아들인다. 
>             - 클럭이란 컴퓨터 부품의 시간단위이다.
>         2. 제어 장치는 해석해야 할 명령어를 받아들인다.
>             - CPU가 해석해야 할 명령어는 **명령어 레지스터**라는 특별한 레지스터에 저장된다.
>         3. 제어 장치는 플래그 레지스터 속 플래그 값을 받아들인다. 
>             - 받아들인 플래그 값을 참고하여 제어신호를 발생시킨다.
>         4. 제어 장치는 시스템 버스, 그중에서 제어 버스로 전달된 신호를 받아들인다. 
>             - 제어 장치가 CPU 외부에 제어 신호를 전달한다라는 말 → 제어 버스로 제어 신호를 내보낸다는 말과 같다.
>             - 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있다.
>             - 제어 장치가 내부에 전달하는 제어 신호에는 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 데어 신호가 있다.

> 2. **레지스터**
>     - **반드시 알아야 할 레지스터**
>         1. **프로그램 카운터 (PC) / 명령어 포인터 (IP)**
>             - 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.
>             - CPU가 메모리 속 프로그램을 순사척으로 읽어들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문이다.
>             - **순차적 실행 흐름이 끊기는 경우**
>                 - 일반적으로 프로그램 카운터는 꾸준히 증가하며 프로그램을 차례대로 실행하지만 종종 실행중인 명령어의 다음 번지 주소가 아닌 전혀 다른 값으로 업데이트 되는 경우가 있다.
>                 - 명령어 중 **JUMP, CONDITIONAL JUMP, CALL, RET**와 같이 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되면 프로그램 카운터에 변경된 주소가 저장된다.
>                 - 또한 **인터럽트가 발생**해도 프로그램의 순차적인 실행 흐름이 끊어진다.
>         2. **명령어 레지스터 (IR)**
>             - 해석할 명령어, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다.
>             - 제어장치는 명령어 레지스터 속 명령어를 받아들이고 해석 후 제어신호를 내보낸다.
>         3. **메모리 주소 레지스터 (MAR)**
>             - 메모리의 주소를 저장하는 레지스터, CPU가 읽어들이고자 하는 주소 값을 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.
>         4. **메모리 버퍼 레지스터 (MBR) / 메모리 데이터 레지스터 (MDR)**
>             - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터, 메모리에 쓰고싶은 값이나 메모리로부터 전달 받은 값을 메모리 버퍼 레지스터를 거친다.
>             - CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거치면 데이터 버스로 주소 받을 값은 메모리 버퍼 레지스터를 거친다.
>         5. **플래그 레지스터 (FR)**
>             - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.
>         6. **범용 레지스터 (GPR)**
>             - 일반적인 상황에서 자유롭게 사용이 가능한 레지스터, **데이터와 주소 모두 저장할 수 있다.**
>         7. **스택 포인터**
>         8. **베이스 레지스터**
>             - **주소 지정에 사용**될 수 있는 특별한 레지스터이다.
>     - **특정 레지스터를 이용한 주소 지정방식 (1) : 스택 주소 지정 방식**
>         - 스택과 스택 포인터를 이용한 주소 지정방식이다.
>             - 스택은 메모리 안에 있고, 메모리 안에는 스택 영역이라는 사용할 영역이 정해져있다.
>             - 이 영역은 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이다.
>             - 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터이다.
>     - **특정 레지스터를 이용한 주소 지정방식 (2) : 변위 주소 지정 방식**
>         - 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다.
>         - 변위 지정 방식을 사용하는 명령어는 **연산 코드 필드, 레지스터 필드, 오퍼랜드 필드**가 있다.
>         - 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 **상대 주소 지정방식, 베이스 레지스터 주소 지정 방식** 등으로 나뉜다.
>             1. **상대 주소 지정 방식**
>                - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다.
>                 - 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용한다.
>             2. **베이스 레지스터 주소 지정 방식**
>                 - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식이다.
                
> 3. **명령어 사이클과 인터럽트**
>     - **명령어 사이클**
>         - **하나의 명령어를 처리하는 정형화 된 흐름**
>         - 프로그램 속 각각 명령어들은 **일정한 주기가 반복되며 실행**되고, 이 **주기**를 명령어 사이클이라고 한다.
>             1. **인출 사이클** 
>                 - 메모리에 있는 명령어를 CPU로 가지고 오는 단계
>             2. **실행 사이클** 
>                 - CPU로 가져온 명령어를 실행하는 단계
>             3. **간접 사이클**
>                 - 명령어를 인출하여 CPU로 가져왔다 하더라도 곧바로 실행할 수 없는 경우가 있다. 이때 **명령어를 실행하기 위해서는 메모리 접근을 한번 더 해야하는데 이 단계**를 간접 사이클이라고 한다.
>     - **인터럽트**
>         - **CPU의 작업을 방해하는 신호**
>         - CPU가 정해진 흐름에 따라 명령어를 처리해 나가다 흐름이 끊기는 상황이다.
>             1. **동기 인터럽트**
>                 - **CPU**에 의해 발생하는 인터럽트
>                 - 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트가 동기 인터럽트이다.
>                 - 이런 점에서 **동기 인터럽트는 예외**라고 부른다.
>                     - **예외의 종류**
>                         1. 폴트 / fault
>                             - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
>                         2. 트랩 / trap 
>                             - 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
>                             - 주로 디버깅할 때 사용한다.
>                         3. 중단 / abort
>                             - CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
>                         4. 소프트웨어 인터럽트 / software interrupt
>                             - 시스템 호출이 발생했을 때 나타난다.
>             2. **비동기 인터럽트** 
>                 - **입출력장치**에 의해 발생하는 인터럽트
>                 - 알림 역할을 한다.
>                 - **하드웨어 인터럽트**라고 지칭할 수 있다.
>                     - **하드웨어 인터럽트 발생 순서**
>                         1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다. 
>                         2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
>                         3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다. 
>                         4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다. 
>                         5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다. 
>                         6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구해 실행을 재개한다. 
>                     - **하드웨어 인터럽트 종류**
>                         1. 막을 수 있는 인터럽트
>                         2. 막을 수 없는 인터럽트
>                 - **인터럽트 요청 신호**
>                     - **CPU의 작업을 방해하는 인터럽트에 대한 요청**
>                     - 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트 하기 전에는 지금 끼어들어도 되는지 CPU에게 물어봐야한다. 이를 **인터럽트 요청 신호**라고 한다.
>                 - **인터럽트 플래그**
>                     - **인터럽트 요청 신호를 받아들일지, 무시할지 결정하는 비트**
>                     - 인터럽트 플래그는 말 그대로 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그이다.
>                     - **CPU가 인터럽트 요청을 수용**하기 위해서는 **플래그 레지스터의 인터럽트 플래그가 활성화** 되어있어야 한다.
>                 - **인터럽트 서비스 루틴**
>                     - **인터럽트를 처리하는 프로그램**
>                     - 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 프로그램으로 **인터럽트 핸들러**라고도 부른다.
>                 - **인터럽트 백터**
>                     - **인터럽트 서비스 루틴을 식별하기 위한 정보**
>                     - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 백터를 전달받는다.