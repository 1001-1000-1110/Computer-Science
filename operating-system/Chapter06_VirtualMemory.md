# 가상 메모리
`가상 메모리`는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.
## 연속 메모리 할당
- - -
- 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당하는 방식

### 스와핑
`스와핑`은 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 `메모리 관리 기법`.
- 스와핑
  - 프로세스들이 요구하는 메모리 주스 공간의 크키가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.
- *스왑 인: 프로세스가 스왑영역(보조기억장치)에서 메모리로 옮겨오는 것 
- *스왑 아웃: 프로세스가 메모리에서 스왑영역으로 옮겨가는 것

### 메모리할당
메모리 공간에 프로세스를 연속적으로 할당하는 3가지 방식
1. 최초 적합(first fit)  
프로세스가 적재될수 있는 공간이 발견되는 즉시 메모리를 할당하는 방식, 검색을 최소화 할 수 있음
2. 최적 적합(best fit)  
프로세스가 적재되는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식.
3. 최악 적합(worst fit)  
프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식.

### 외부 단편화
연속 메모리 할당 방식에서 비롯되는 문제인 `외부 단편화`
- 외부 단편화(external fragmentation)
  - 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

- 외부단편화를 해결하는 방법
  - 압축(compaction)
    - 흩어져있는 빈 메모리 공간들을 하나로 모으는 방식
    - 압축을 진행하는 과정에서 시스템은 하던일을 멈춰야하는 `오버헤드`가 발생함
  - 페이징 기법

## 페이징을 통한 가상 메모리 관리
`가상 메모리`는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.
- 가상 메모리
  - 페이징
  - 세그멘테이션
  
## 페이징
`페이징`은 프로세스의 논리 주소 공간을`페이지`라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 `프레임`이라는 페이지와 동일한 크기의
일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 `메모리 관리 기법`
- 페이지 단위로 `페이지 인(스왑 인)`/`페이지 아웃(스왑 아웃)`이 일어남
- 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만 메모리에 적재할 수 있음.(메모리보다 더 큰 프로세스 실행가능)

## 페이지 테이블  
- 프로세스가 메모리에 불연속적으로 배치되면 cpu가 어떻게 다음에 실행할 명령어를 찾을까?  
 >  물리주소에 불연속 적으로 배치되더라도 논리주소에는 연속적으로 배치되도록 `페이지 테이블`을 사용함.
- 페이지 테이블
  - 페이지 번호와 프레임 번호를 짝지어 주는이정표의 역할로 즉, 어떤 페이지가 어떤 프레임에 할당되었는지 cpu에게 알려줌.
  - 모든 프로세스는 각각 `페이지 테이블`을 가지고 있음.
- 페이지 테이블 베이스 레지스터(PTBR: Page Table Base Register)
  - cpu내부의 레지스터로 각 프로세스의 `페이지 테이블`이 적재된 `주소`를 가리킨다.

- TLB(Translation Lookaside Buffer)  
  cpu 근처(MMU내부)에 위치한 페이지 테이블의 `캐시 메모리`로 페이지 테이블이 메모리에 위치하는 경우, 메모리 접근 시간이 2배로 늘어나는 문제를 해결하기 위해 사용됨
  > - 메모리에 있는 페이지 테이블을 보기 위해서
  > - 페이지 테이블을 통해해 알게된 프레임에 접근하기 위해서
  - 페이지 테이블의 일부 내용을 저장함(참조 지역성의 원리)
  - TLB히트 : cpu가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있는 경우
  - TLB미스 : cpu가 발생한 논리 주소에 대한 페이지 번호가 TLB에 없는 경우

### 페이징에서의 주소 변환
하나의 페이지, 프레임은 여러 주소를 포괄하고 있음. 따라서 특정 주소에 접근하기 위해서는 2가지 정보가 필요함.
- 페이징 시스템에서 모든 논리주소가 기존적으로 `페이지 번호`와 `변위`로 구성됨
- 즉, <페이지번호, 변위> 를 <프레임번호,변위>로 변환함.

### 페이지 테이블 엔트리
페이지 테이블의 각각의 행을 `페이지 테이블 엔트리(PTE:Page Table Entry)`라고 칭함
- 페이지 테이블 엔트리에 담기는 정보들
  - 페이지번호 프레임 번호
  - 유효비트
    - 현재 페이지가 메모리에 적재되어 있는 경우 1
    - 현재 페이지가 메모리에 적재되어 있지 않응 경우 0
      - `페이지 폴트`라는 예외가 발생함.
        1. cpu는 기존작업내용을 백업한다.
        2. 페이지 폴트 처리 루틴을 실행한다.
        3. 원하는 페이지를 메모리로 가져온다.
        4. 유효비트를 1로 변경한다.
  - 보호비트
    - 페이지 보호를 위한 비트로, 
    - 읽기(Read), 쓰기(Write), 실행(eXecute)의 조합인 rwx으로 권한을 나타낸다.
  - 참조비트
    - cpu가 페이지에 접근한 적이 있는지 나타냄
  - 수정비트
    - 페이지에 데이터를 쓴적이 있는지 없는지 수정여부를 알려줌
    - 수정비트가 1인경우, 수정이 발생했으므로 페이지가 메모리에서 사라질 때, 보조기억장치도 수정해야함

### 쓰기시 복사
### 계층적 페이징

## 페이지 교체와 프레임 할당
- - -
### 요구 페이징
- 요구 페이징(demand paging) : 프로세스를 메모리에 적재할때, 필요한 페이지만 메로리에 적재하는 기법

### 페이지 교체 알고리즘
요구 페이징 기법으로 페이지를 메모리에 적재하다, 메모리가 가득 차게되면 일부 페이지를 보조기억장체로 내보내야 한다.
이때, 어떤 페이지를 내보낼지 결저하는 방법을 `페이지 교체 알고리즘`이라고 함.
- 페이지 폴트가 적게 발생해야 좋은 알고리즘
- 페이지 참조열(page reference string)
  - cpu가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지 열
  - 페이지폴트 발생횟수를 파악하기 위해 사용됨.
  
1. FIFO 페이지 교체 알고리즘(First-In First-Out Page Replace Algorithm)
   - 메모리에 가장 먼저 올라온 페이지를 내쫓는 방식
   - 실행초기에 적재된 페이지 속에 프로그램 실행에 필수적인 내용이 포함되어 있는 경우 문제가 발생함.

2. 2차 기회 페이지 교체 알고리즘(second chance page replacement algorithm)
   - FIFO 페이지 교체 알고리즘의 문제점을 어느정도 보완함
     - 페이지의 참조비트가 1인 경우, 참조비트를 0으로 만들고 적재시간을 현재시간으로 함
     - 페이지의 참조비트가 0인 경우, 내보냄

3. 최적 페이지 교체 알고리즘(optimal page replacement algorithm)
   - 앞으로 활용빈도가 가장 낮은 페이지를 교체하는 알고리즘
   - 가장낮은 페이지 폴트률을 보장하는 알고리즘
   - 실제구현이 어려워 다른 페이지 교체 알고리즘의 이론상 성능을 평가하는 목적으로 사용됨.
   
4. LRU 페이지 교체 알고리즘(LRU: Least Recently Used Page Replacement Algorithm)
   - 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

### 스래싱과 프레임 할당
프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수 밖에 없음.
- 스래싱(thrashing) 
  - 지나치게 빈번한 페이지 교체로 인해 CPU이용률이 낮아지는 문제.
  - 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제

- 프레임할당  
  스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요한 최소한의 프레임 수가 보장되지 않았기 때문임.
  따라서 운영체제는 각 프로세스들에게 필요한 최소한의 프레임의 수를 파악하고 적절한 수 만큼 프레임을 할당 해야함  
  - 균등할당
    - 모든 프로세스에 동일한 프레임을 배분함
  - 비례 할당
    - 프로세스의 크기에 비례하여 프레임을 배분함
  - 프로세스의 실행을 보고 필요한 프레임을 배분하는 `동적 할당 방식`
    - 작업 집합 모델(working set)
        - `작업 집합`의 크기만큼 프레임을 할당해줌
        - *`작업 집합` : 실행중인 프로세스가 일정 시간동안 참조한 페이지 집합
    - 페이지 폴트 빈도(PFF : Page- Fault Frequency)
      - 페이지 폴트율에 상한선과 하산선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식
      > - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다
      > - 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다.