## Type

### Hash

> 데이터를 빠르게 찾기 위해 Key에 Hash 함수를 적용해 데이터의 위치를 결정하는 데이터 구조이다.
> 
> 
> **Hash 자료구조는 빠른 데이터 검색, 삽입, 삭제가 요구되는 상황에서 사용**한다. 
> 

### Stack, Queue

> **Stack은 LIFO,** 즉 후입선출 구조를 가진 자료구조이다.
> 
> 
> 특정 작업을 역순으로 처리할 필요가 있을 때 유용하게 사용된다. 
> 

> **Queue는 FIFO,** 즉 선입선출 구조를 가진 자료구조이다.
> 
> 
> 데이터가 들어온 순서대로 처리해야할 때 유용하게 사용된다. 
> 

### Heap

> 데이터에서 **최대값, 최소값을 빠르게 찾기 위해 사용되는 완전 이진 트리 기반의 자료구조**이다.
> 
> 
> 최대값, 최소값의 빠른 추출과 요소의 추가, 삭제를 로그 시간 복잡도로 처리할 수 있기 때문에 데이터의 동적 관리가 필요한 경우 매우 효율적이다. 
> 

### Sort

> **자료의 순서를 일정한 기준에 따라 재배열 하는 것**을 목표로 한다.
> 
> 
> 데이터의 처리와 분석을 위해 정렬 로직을 적용해야 할 때 사용한다. 
> 

### Exhaustive Search

> **모든 가능한 경우의 수를 하나씩 검토하여 문제의 해답을 찾는 방식**이다.
> 
> 
> 문제의 가능한 모든 경우를 탐색해 가장 확실하게 정답을 찾을 수 있다. 
> 

### Greedy

> **문제 해결을 위해 각 단계에서 최적의 선택을 하는 방식**이다.
> 
> 
> 각 단계에서의 선택이 이후 선택에 영향을 미치지 않고, 각 단계의 선택이 최종 결과에 포함되는 경우 특히 유효하다. 
> 

### DP

> **복잡한 문제를 간단히 여러 개의 하위 문제로 나누어서 푸는 방식**이다.
> 
> 
> 큰 문제를 작은 문제로 분할하여 해결한 결과를 저장하고, 이를 활용해 전체 문제 해결에 접근한다. 
> 
> **Memoization 기법을 사용**해 중복 계산을 방지하고, 동일한 하위 문제가 다시 발생했을 시 저장된 결과를 재사용함으로써 전체 문제의 해결을 더 빠르게 진행할 수 있도록 한다. 
> 
> 특히 최적 부분 구조와 중복되는 하위 문제를 갖는 경우 유용하게 사용된다. 
> 

### DFS, BFS

> **DFS는 깊이 우선 탐색 방식**으로 **가능한 깊이를 우선하여 Node를 탐색**한다.
> 
> 
> 이는 **Stack을 사용하거나 재귀적으로 구현**할 수 있다. 
> 

> **BFS는 너비 우선 탐색 방식**으로 **가까운 Node부터 우선적으로 탐색**한다.
> 
> 
> **Queue를 사용하여 구현**된다. 
> 

### Binary Search

> 정렬된 데이터에서 특정 값을 빠르게 찾는 방식으로 **탐색 범위를 반으로 줄여가며 데이터를 찾는다.**
> 
> 
> 시간 복잡도는 O(log n)이다. 
> 

### Graph

> **Node와 Node를 연결하는 Edge로 구성된 자료구조**이다. 
연결된 객체 사이의 관계를 표현하는 데 사용된다. 
문제 유형에 따라 Graph는 방향성이 있거나 없을 수 있으며, 가중치가 있는 Edge를 사용할 수도 있다.
> 

## Variety

| Hash | Stack | Queue | Heap | Sort | Exhaustive Search | Greedy  | DP | DFS | BFS | Binary Search | Graph |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 중복검사 | 괄호검사 | BFS | K번째 큰, 작은 요소 찾기 | 기본 정렬 | 순열과 조합 | 최소 동전 문제 | 피보나치 수열 | 모든 연결 요소 탐색 | 최단 경로 | Basic Binary Search | DFS, BFS를 사용한 경로 탐색, 모든 경로 찾기 |
| Anagram | 후위 표기법 | 최단 경로 | Data Stream의 중간값 찾기 | K번째 큰, 작은 요소 찾기 | 부분 집합 | 간선 선택 문제 최소 신장 트리 | 최소 경로 찾기 문제 | Cycle 검출 | Level 별 탐색 | Parametric Search | 최단 경로 문제 (Dijkstra, Bellman-Ford, Floyd-Warshall) |
| 문자열 빈도 수 계산 | Histogram에서 가장 큰 직사각형 찾기  | Printer Queue | 우선순위 Queue 구현 | 문자열 정렬 | Bit Mask | 활동 선택 문제 | 최장 증가 부분 수열 (LIS) | 위상 정렬 | 최소 Spanning Tree | 부동 소수점에서의 Binary Search | Cycle 감지 (방향 Graph에서 Cycle 찾기, 무방향 Graph에서 Cycle 찾기) |
| 교집합, 합집합 | 뒤집기 | 고객 대기열 | Dijkstra | 좌표 정렬 | Back Tracking | 작업 Scheduling | 0 / 1 배낭 문제 | 경로 탐색 | Puzzle, Game | 배열의 특정 조건을 만족하는 구간 찾기 | 연결 요소 찾기, 강하게 연결된 구성 요소 (SCC) |
| 부분 배열 합 | 주식 가격 | CPU Scheduling | Huffman Coding | 구조체, 객체 정렬 | 재귀적 탐색 | 분할 가능 배낭 문제 | 최장 공통 부분 수열 (LCS) | Graph 색칠 |  |  | 최소 신장 Tree (Kruskal, Prim’s) |
| 보석, 돌 | 빌딩, 풍경의 Skyline | Resource Caching | 여러 배열 병합 | 주파수 정렬 | Graph 탐색 | 간격 합치기 문제 | 동전 교환 문제 |  |  |  | Network Flow (최대 유량 문제, 최소 Cut 문제) |
|  |  | Running Manager Scheduler | 작업 Scheduling | 간격 병합 | Simulation |  |  |  |  |  |  |
|  |  |  |  | 안정 정렬, 불안정 정렬 |  |  |  |  |  |  |  |