## 소켓을 작성한다

> 애플리케이션은 데이터를 송신하기 위해 먼저, 프로토콜 스택에 의뢰하여 소켓을 생성한다.
> 

### 프로토콜 스택의 내부 구성

- 프로토콜 스택 : OS에 내장된 네트워크 제어용 소프트웨어
    - TCP : TCP 프로토콜을 사용한 데이터 송수신
        
        브라우저나 메일 등의 일반적인 어플리케이션
        
    - UDP : UDP 프로토콜을 사용한 데이터 송수신
        
        DNS서버에 대한 조회나 사진, 영상
        
    - IP :  IP프로토콜을 사용한 패킷 송수신
        - 패킷 : 데이터를 작게 나눈 것
        - ICMP : 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지 통지
        - ARP : IP주소에 대응하는 이더넷의 MAC주소를 조사
- LAN 드라이버 : LAN 어댑터의 하드웨어를 제어
    - LAN 어댑터 : 케이블에 대해 신호를 송수신 동작

### 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택은 내부에 제어정보를 기록하는 메모리 영역을 갖으며, 이 곳에 통신을 위한 제어정보를 기록
    
    제어정보 : 상대의 IP주소, 포트 번호, 통신 진행 상태 등
    
- 제어정보가 소켓의 실체
- 프로토콜 스택은 이 제어정보를 참조하며 동작

### Socket을 호출했을 때의 동작

- socket()
    - 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 생성
    - 소켓 생성 시, 소켓 한 개 분량의 메모리 영역 확보
    - 소켓을 생성하고 해당 소켓임을 나타내는 디스크럽터를 어플리케이션에 반환
    - 어플리케이션은  이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크럽터를 통지

## 서버에 접속한다

> 클라이언트측의 소켓을 서버측의 소켓에 접속한다.
> 

### 접속의 의미

소켓 생성 후 어플리케이션이 connect를 호출하면 프로토콜 스택은 클라이언트 소켓을 서버측 소켓에 접속한다.(소켓의 생성 만으로는 통신 상대를 알지 못함)

→ 통신 상대와 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만든다.

제어정보 : 클라이언트의 IP주소나 포트번호 등

```
💡 버퍼 메모리
송수신하는 데이터를 일시적으로 저장하는 메모리 영역으로, connect호출 시 확보.
```

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어정보 = MAC 헤더 + IP 헤더 + TCP 헤더

패킷 = 제어정보 + 데이터 조각

- TCP 헤더
    
    클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
    

- 접속, 송수신, 연결 끊기의 각 단계에서 클라이언트와 서버가 통신할 때마다 이 제어정보를 부가
- 접속 동작의 경우 데이터가 없고 제어 정보만으로 이루어짐

```
💡 소켓에 기록되는 제어 정보
소켓에는 어플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등 송수신 동작의 진행 상황이 수시로 기록되며 프로토콜 스택은 소켓에 저장된 정보를 참조하며 동작한다.
```

### 접속 동작의 실제

3-handshaking

```markdown
connect(<디스크럽터>, <서버측의 IP주소와 포트번호>, ... )
```

클라이언트의 TCP 담당 부분과 서버의 TCP담당 부분과의 사이에 제어 정보를 주고 받음

1. 클라이언트 → `SYN:1` → 서버
    - 송신처와 수신처의 포트번호를 설정하여 클라이언트 소켓과 서버 소켓을 지정
    - 컨트롤 비트 SYN를 1로 설정하여 TCP헤더를 생성
    - IP로 건네주어 송신을 의뢰
    - 서버측의 IP가 패킷을 받고 TCP로 넘김
    - TCP 헤더를 조사하여 수신처 포트 번호에 해당하는 소켓을 찾음
    - 소켓에 정보를 기록
2. 서버 → `SYN:1`/`ACK:1` → 클라이언트
    - 송신처와 수신처의 포트 번호와 SYN비트를 1로 설정한 TCP헤더 생성
    - ACK도 1로 만듬(클라이언트에서 전송한 패킷을 정상적으로 받은 것을 알리기 위한 동작)
    - IP에 건네주어 반송 의뢰
    - 클라이언트의 TCP에서 TCP헤더를 조사하여 SYN가 1이면 접속 성공이므로 서버의 IP주소나 포트번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록
3. 클라이언트 → `ACK:1` → 서버
    - 서버에서 전송한 패킷이 도착했다는 것을 알리기 위해 ACK를 1로 만든 TCP헤더를 반송

→ 소켓은 데이터를 송수신 할 수 있는 상태가 됨!

## 데이터를 송수신한다

> 프로토콜 스택은 의뢰받은 메시지를 작은 조각으로 분할하여 서버를 향해 송신한다.
> 

### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

어플리케이션이 write를 호출하여 송신데이터를 프로토콜 스택에 건네준다.

- 프로토콜 스택은 송신 데이터를 바이너리 데이터가 1바이트씩 차례로 나열되어 있는 것이라고 인식
- 프로토콜 스택은 데이터를 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장

```
💡 패킷 송신 기준 : 용량 vs 시간

- 용량 : 어느정도 데이터를 저장한 후, 송수신 동작을 진행
    
    - MTU : 한 패킷이 운반할 수 있는 디지털 데이터의 최대 길이(이더넷에서는 보통 1500바이트)
    - MSS : 헤더를 제외하고, 한 패킷으로 운반할 수 있는 TCP 데이터의 최대 길이
- 시간 : 타이머를 재서 일정 시간 이상 경과되면 패킷을 송신
- 
용량을 중시하면 네트워크 이용 효율인 높아지지만 버퍼에 머무는 시간만큼 송신 동작 지연 우려, 시간을 중시하면 지연 시간은 적어지지만 네트워크 이용 효율이 떨어지므로 양자를 절충하여 실행해야한다~
```

### 데이터가 클 때는 분할하여 보낸다

HTTP 리퀘스트 메시지는 보통 한 개의 패킷에 들어가지만, 폼을 사용하여 큰 데이터를 보낼 경우 한 개의 패킷에 들어가지 않을 수 있음

→ 송신 버퍼에 저장된 데이터는 MSS의 길이를 초과하므로 TCP는 데이터를 맨 앞부터 차례로 MSS 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신 (소켓에 저장된 제어 정보를 바탕으로 TCP헤더 추가)

### ACK번호를 사용하여 패킷이 도착했는 지 확인한다

- 시퀀스 번호 : 현재 송신되는 데이터 조각이 몇 번째 바이트에 해당하는 지
    
    실제로는 시퀀스 번호를 1부터 시작하지 않고 난수를 바탕으로 산출
    
    → 접속 단계에서 SYN비트를 1로 하며 시퀀스 번호의 초기값을 통지
    
- ACK번호 : 수신측에서 몇 번째 바이트까지 수신했는 지
    
    서버측에서 시퀀스 번호가 1인 패킷 수신 후, 시퀀스 번호가 2921인 패킷을 수신했다면 누락을 감지하여 ACK번호를 1461로 설정하여 응답
    
- 실제 동작 과정
    - 접속 단계(3 hand shaking)
        1. 클라이언트 → 서버
            
            시퀀스 번호 초기값, SYN비트=1
            
        2. 서버 → 클라이언트
            
            시퀀스 번호 초기값, ACK번호(클라이언트측의 시퀀스 번호 초기값), ACK비트=1, SYN비트=1
            
        3. 클라이언트 → 서버
            
            ACK번호(서버측의 시퀀스 번호 초기값), ACK비트=1
            
    - 데이터 송수신
        - 클라이언트 송신
            1. 클라이언트 → 서버
                
                시퀀스 번호 + 데이터
                
            2. 서버 → 클라이언트
                
                ACK번호
                
        - 서버 송신
            1. 서버 → 클라이언트
                
                시퀀스 번호 + 데이터
                
            2. 서버 → 클라이언트
                
                ACK번호
                

```
💡 회복처리
송신측에서는 ACK번호, 수신측에서는 시퀀스 번호를 통해 데이터 누락을 체크
```

### 패킷 평균 왕복 시간으로 ACK번호의 대기시간을 조정한다

타임아웃값 : ACK번호가 돌아오는 것을 기다리는 시간

TCP는 타임아웃값을 동적으로 변경한다.

### 윈도우 제어 방식으로 효율적으로 ACK번호를 관리한다

- 윈도우 제어 : 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법으로, 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 이 양을 초과하지 않도록 송신
- 윈도우 사이즈 : 수신 가능한 데이터 양의 최대값
    
    수신 버퍼에 빈 부분이 생기면 윈도우 필드를 통해 송신측에 알림
    

### ACK번호와 윈도우를 합승한다

- 윈도우의 값은 송신측이 데이터를 송신할 때마다 송신한 데이터만큼 감산
- 수신 버퍼의 빈 영역이 늘어났을 때마다 송신측에 윈도우 통지

ACK번호와 윈도우를 한 개의 패킷에 합승시켜 통지하여 패킷의 수를 줄일 수 있다. 또한 ACK번호와 윈도우 통지가 연속하여 일어나면 **최후의 것**만 통지하여 패킷의 수를 줄인다.

### HTTP응답 메시지를 수신한다

서버에서 돌아오는 응답 메시지를 받기 위해 read를 호출

- 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 어플리케이션에 건네줌
- 데이터 조각을 수신버퍼에 일시 보관하고 조각을 연결하여 데이터를 원래 모습으로 복원한 후 어플리케이션에 건네줌

## 서버에서 연결을 끊어 소켓을 말소한다

> 메시지 송수신이 끝나면 서버에서 연결을 끊고 소켓을 말소한다.
> 

### 데이터 보내기를 완료했을 때 연결을 끊는다

4-handshaking

- 데이터 보내기를 완료한 쪽에서 연결끊기 단계에 들어간다
- 웹에서는 서버가 응답메시지를 반송 완료하면 서버측이 연결 끊기 단계로 들어간다

1. 서버 → `FIN:1` → 클라이언트
    - 서버측의 어플리케이션에서 Socket라이브러리의 close를 호출
    - 프로토콜 스택이 TCP헤더를 만들고 FIN비트를 1로 설정
    - IP에 의뢰하여 클라이언트에게 송신 요청
2. 클라이언트 → ACK번호 → 서버
    - 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기동작에 들어갔다는 것을 기록
    - FIN이 1인 패킷을 받은 사실을 알리기 위해 ACK번호를 서버측에 반송
    - 어플리케이션의 데이터 수신이 완료될 때까지 대기
3. 클라이언트 → `FIN:1` → 서버
    - 서버에서 보낸 데이터 수신이 완료 되면 클라이언트측의 어플리케이션도 close를 호출
    - FIN비트를 1로 설정한 TCP헤더를 만들고 IP에 송신 의뢰
4. 서버 → ACK번호 → 클라이언트
    - FIN이 1인 패킷을 받은 사실을 알리기 위해 ACK번호를 클라이언트측에 반송
    - 서버에서 ACK번호가 돌아오면 서버와의 대화 끝

### 소켓을 말소한다

오작동을 막기 위해 소켓을 즉시 말소하지 않고 잠시 기다린 후 말소한다.

오작동 예시 : 위의 4번 동작에서 클라이언트에 ACK번호가 돌아오지 않으면 다시 한번 서버측에 FIN을 보낸다. 이 때, 서버측에 기존의 소켓은 말소 되었고 말소된 소켓과 같은 번호의 소켓이 만들어졌다면? 연결 끊기 동작에 들어가버림

따라서 보통 몇 분 정도 기다린 후 소켓을 말소함

### 데이터 송수신 동작을 정리한다

1. 접속동작(3-handshaking)
    
    서버측에서 어플리케이션이 동작하기 시작했을 때, 소켓을 만들고 접속대기 상태로 만들고, 클라이언트에서 서버를 향해 접속 동작을 실행
    
    1. 클라이언트가 `시퀀스 번호의 초기값 + 윈도우 값 + SYN:1`송신
    2. 서버에서 `시퀀스 번호의 초기값 + 윈도우 값 + ACK번호 + ACK:1 + SYN:1`송신
    3. 클라이언트가 `ACK번호 + ACK:1`의 TCP헤더를 만들어 서버로 송신
2. 송수신 동작
    
    클라이언트가 서버로 리퀘스트 메시지를 보내는 것부터 시작
    
    1. 클라이언트 측 TCP는 리퀘스트 메시지를 적당한 크기의 조각으로 분할하여 `시퀀스 번호 + 데이터`송신
    2. 서버는 `ACK번호 + ACK:1` 를 송신
        
        서버측 어플리케이션에게 데이터를 번네주어 수신 버퍼에 빈 영역이 생기면, `윈도우 값`송신
        
    3. 서버가 응답 메시지 반송
3. 연결 끊기 동작(4-handshaking)
    
    서버가 응답 메시지를 보내기를 완료하면 연결 끊기 동작에 들어감
    
    1. 서버측은 `FIN:1`송신
    2. 클라이언트 측은 `ACK번호 + ACK:1` 송신
    3. 클라이언트 측은 데이터 송신이 완료 되면 `FIN:1` 송신
    4. 서버 측은 `ACK번호 + ACK:1` 송신

## IP와 이더넷의 패킷 송수신 동작

> 프로토콜 스택과 LAN 어댑터가 연대하여 작은 조각으로 분할된 데이터를 패킷 형태로 묶고 전기나 빛의 신호로 변환하여 케이블에 송출한다.
> 

### 패킷의 기본

TCP/IP 패킷 = `MAC헤더 + IP헤더 + TCP헤더 + 데이터 조각`

IP헤더 : IP용 헤더 / MAC헤더 : MAC용 헤더

서브넷은 라우터와 허브라는 패킷 중계 장치에서 다음과 같은 역할을분담하며 패킷을 운반

- 라우터가 목적지를 확인하여 다음 라우터를 나타냄
    
    IP가 목적지(IP주소)를 확인하여 다음 IP의 중계장치(라우터)를 나타냄
    
- 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착
    
    서브넷 안에 있는 이더넷이 다음 중계장치(라우터)까지 패킷을 운반
    
1. 송신처에서 액세스 대상 서버의 IP주소를 IP헤더의 수신처에 기록
2. IP는 이 수신처가 어느 방향에 있는 지 조사하고, 해당 방향에 있는 다음 라우터 조사
3. 다음 라우터에 패킷이 도착하도록 이더넷에 의뢰
4. 이더넷에서 다음 라우터의 MAC주소를 조사하고 MAC헤더에 기록
5. 패킷 송신 - (1)
6. 허브에 도착
7. 허브는 이더넷용 표를 통해 MAC헤더에 기록된 MAC주소의 목적지를 조사하여 송신 - (2)
8. 라우터에 도착
9. 라우터는 IP용 표를 통해 IP헤더의 수신처를 결합하여 다음 라우터 조사
10. 3번 과정 부터 반복 → 반복하다보면 패킷이 목적지에 도착

### 패킷의 송수신 동작의 개요

IP 담당 부분은 패킷을 상대에서 송출

1. TCP가 IP에게 패킷 송신 의뢰
    - 데이터 조각에 TCP헤더를 부가한 것을 IP에게 전달
    - IP는 IP헤더와 MAC헤더를 부가
        - IP헤더 : IP프로토콜 규칙에 따라 IP주소로 표시된 목적지까지 패킷을 전달하기 위한 제어정보를 기록
        - MAC헤더 : 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어정보 기록
2. IP가 네트워크용 하드웨어(LAN 어댑터)에게 패킷을 건네줌
    - 패킷을 디지털 데이터로 전달
    - LAN 어댑터에 의해 전기나 빛의 신호로 케이블에 송출
    - 신호는 허브나 라우터 등의 중계 장치에 도착하고 중계장치가 상대가 있는 곳까지 패킷을 전달
3. 회답이 오면 네트워크용 하드웨어가 IP로 패킷을 건네줌
    - 신호의 모습을 한 패킷을 디지털 데이터로 되돌려서 전달
4. IP가 TCP헤더와 데이터 조각을 TCP에게 건네줌

### 수신처 IP주소를 기록한 IP헤더를 만든다

IP는 TCP에게 패킷 송신을 의뢰받으면 IP헤더를 만들어 TCP헤더의 앞에 붙인다

- 수신처 IP주소
    
    TCP에서 통지한 통신 상대의 IP주소를 수신처 IP주소로 설정
    
- 송신처 IP주소
    - 컴퓨터에 할당된 IP주소는 사실 컴퓨터에 할당된 것이 아닌, LAN  어댑터에 할당.
    - 한 컴퓨터가 여러개의 LAN 어댑터를 장착한다면, 한 대의 컴퓨터에 할당된 IP주소가 여러개가 됨
    - 따라서 어느 LAN 어댑터를 사용하여 패킷을 송신할 지 판단해야함
    - IP용 표(경로표)를 참고하여 어느 LAN 어댑터에서 패킷을 송신해야하는지 판단하고 해당 LAN 어댑커에 할당된 IP주소를 IP헤더의 송신처 IP주소로 설정
        - network destination : 수신처의 IP주소
        - interface : LAN어댑터 등 네트워크용 인터페이스
        - gateway : 다음 라우터의 IP주소
        
        interface를 송신처 IP주소로 설정 후, 다음 라우터의 IP주소인 gateway로 패킷을 건네줌
        

### 이더넷용 MAC헤더를 만든다

IP헤더를 만들었으면 이 앞에 MAC헤더를 붙인다

MAC 주소 : LAN 어댑터를 제조할 때 설정된 주소

- 이더 터입
    
    MAC헤더를 제외한 패킷의 내용물(IP나 ARP라는 프로토콜의 소켓)이 무엇인지를 나타냄
    
    ex) IP프로토콜일 경우 0800
    
- 송신처 MAC 주소
    
    어느 LAN 어댑터에서 송신할 지 판단하고 해당 LAN어댑터에 할단된 MAC주소를 설정
    
- 수신처 MAC 주소
    
    다음 라우터의 IP주소인 gateway가 패킷을 건네줄 상대임
    
    → 상대의 MAC주소는 모르기 때문에 이 IP주소를 통해 MAC주소를 조사하는 동작을 실행해야함 (ARP)
    

```
💡 MAC 주소를 사용하는 이유?
컴퓨터(LAN 어댑터)에 할당되는 IP주소는 동적으로 변할 수 있기 때문에 불변의 하드웨어 주소인 MAC주소를 사용한다.
```

### ARP로 수신처 라우터의 MAC주소를 조사한다

ARP(Address Resolution Protocol) : 연결되어 있는 전원에게 패킷을 전달하는 브로드 캐스트를 이용하여 ‘oo라는 IP주소를 가지고 있는 분 있나요?’라고 질문하여 IP주소에 해당하는 MAC주소를 얻는 방법

- ARP를 통해 다음 라우터 IP주소에 해당하는 MAC주소를 얻고 MAC헤더에 설정
- MAC헤더를 IP헤더 앞에 붙이면 패킷 완성
- LAN 어댑터는 완성된 패킷을 송신

```
💡 ARP 캐시
패킷을 송신할 때, ARP캐시를 조사하여 상대의 MAC주소가 저장되어 있는 지 확인. 저장되어 있다면 ARP를 조회하지 않고 ARP캐시에 저장된 값을 사용
```

### 이더넷의 기본

이더넷이란?

다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술

1. 원래의 이더넷은 **10BASE5**로, 케이블을 통해 신호가 전체에 흐르고 컴퓨터는 수신처의 MAC주소로 수신을 결정
2. 그 후, 리피터 허브를 사용했고 신호는 리피터 허브에서 흩뿌려져서 전체에 전달
3. 현재는 **스위칭 허브**를 사용하며, 수신처 MAC주소로 나타내는 기기한테만 신호가 흐름

### IP패킷을 전기나 빛의 신호로 변환하여 송신한다

- LAN 어댑터는 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출한다
- LAN 어댑터를 제어하기 위해 LAN 드라이버 소프트웨어가 필요하다
- 초기화 작업을 통해 LAN어댑터에서 이더넷의 송수신 동작을 제어하는 MAC이라는 회로에 MAC주소를 설정한다

### 패킷에 3개의 제어용 데이터를 추가한다

- LAN드라이버는 IP담당 부분에서 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리에 복사한다
- 복사 후, 패킷을 송신하도록 MAC회로에 명령을 보내면 MAC회로의 작업이 시작된다
- MAC회로는 패킷의 맨 앞에 프리앰블과 스타트 프레임 딜리미터를, 맨 끝에는 프레임 체크 시퀀스(FCS)를 부가한다
    - 프리앰블 : 송신하는 패킷을 읽을 떄의 타이밍을 잡기 위한 비트열
    - 스타트 프레임 딜리미터 : 패킷의 시작을 나타내는 비트열
    - FCS : 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우 이것을 검출하기 위해 사용하는 비트열

### 허브를 향해 패킷을 송신한다

1. 반이중 모드 - 리피터 허브
    
    케이블에 신호가 흐르고 있다면 끝날 때까지 기다림
    
2. 전이중 모드 - 스위칭 허브
    
    송신과 수신을 동시에 실행하면서 충돌이 발생하지 않음
    

### 돌아온 패킷을 받는다

1. LAN어댑터에 데이터가 도착
2. FCS(오류 검출 비트)에 문제가 없다면, MAC헤더의 수신처 MAC주소와 자신의 MAC주소를 비교하여 동일한지 확인
3. 동일하다면(자신에게 오는 데이터가 맞다면) 패킷을 받아 버퍼 메모리에 저장
4. 패킷을 수신한 사실을 인터럽트를 통해 CPU에게 알림
5. LAN 드라이버가 호출되어 LAN 어댑터를 제어하며 수신 동작 실행
6. LAN어댑터의 버퍼 메모리에서 수신한 패킷을 추출하여 타입 필드의 값으로부터 프로토콜을 판별
7. 타입의 값이 0800이면 패킷의 내용은 IP프로토콜의 데이터이므로 TCP/IP 프로토콜 스택에 패킷을 건네줌
8. 프로토콜 스택이 어느 어플리케이션에 대응하는 패킷인지 판단하여 적절한 조치를 취함

### 서버의 응답 패킷을 IP에서 TCP로 넘긴다

1. IP담당 부분은 수신처의 IP주소와 LAN어댑터에 할당된 IP주소가 일치하는지 확인
    - 일치하지 않는다면, 오류가 있는 것임. IP담당 부분이 ICMP라는 메시지를 사용하여 통신 상대에게 오류를 통지
2. IP주소가 일치하면 이것을 수신
3. 하나의 패킷이 여러개로 분할되어 왔다면, 분할된 패킷이 전부 도착할때까지 기다렸다가 패킷을 원래의 모습으로 되돌리는 동작 실행
    - 플래그 : 분할된 패킷인지 아닌지
    - ID : 분할된 패킷을 식별
4. 패킷을 TCP에게 넘겨줌
5. TCP는 IP헤더에 기록된 수신처 IP주소, 송신처 IP주소, TCP헤더에 기록된 수신처 포트 번호, 송신처 포트번호를 조사하여 해당하는 소켓을 찾아 적절한 동작 실행

## UDP프로토콜을 이용한 송수신 동작

> 보통의 어플리케이션은 TCP프로토콜을 이용하여 송수신 동작을 하지만, 경우에 따라 UDP 프로토콜을 이용한다.
> 

### 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다

- TCP는 오류로 인해 도착하지 않은 패킷만 다시 보낸다
- TCP를 사용하지 않는다면, 패킷이 한 개만 없어져도 전체를 다시 보내야하므로 비효율적이다
- 하지만? **TCP처럼 복잡한 구조를 사용하지 않아도 효율적으로 데이터를 보낼 수 있는 상황이 있다.**
    1. 데이터가 한 개인 패킷에 수용할 수 있을 만큼 길이가 짧은 경우 ex) DNS
    2. 패킷을 다시 보낼 필요가 없거나 다시 보내도 쓸모가 없을 경우 ex) 음성 및 영상
- UDP
    - 수신확인과정이나 윈도우가 없다
    - 데이터 송수신 전에 제어 정보를 주고받지 않는다
    - 접속이나 연결끊기 단계가 없다

### 제어용 짧은 데이터

- DNS서버에 대한 조회 등은 한 개의 패킷으로 끝나는 경우가 많으므로 UDP를 사용
- 패킷이 없어져도 프로토콜 스택은 신경쓰지 않음
- 회답의 유무로 수신확인
    
    오류가 발생하면 회답이 돌아오지 않으므로 어플리케이션이 그 사실을 알아차리고 데이터를 한번 더 다시보내면 그만임
    

### 음성 및 영상 데이터

- 음성이나 영상 데이터를 보낼 때 UDP를 사용한다
- TCP같이 수신 응답 확인을 통해 오류를 검출하여 다시 보낸다면, 다시 보낼 때 시간이 걸리므로 다시 보내도 재생 타이밍이 맞지 않을 수도 있음
    
    → 재생 타이밍이 맞지 않으면, 중간에 끊긴 음성이나 영상을 원래대로 되돌릴 수 없기 때문에 늦게 도착하면 쓸모 없음
    
- 음성이나 영상은 데이터가 다소  없어도 치명적인 문제가 되지 않음
    - 음성은 없어진 순간 ‘치직’하면서 소리가 끊길 뿐
    - 영상은 잠깐 멈출 뿐
