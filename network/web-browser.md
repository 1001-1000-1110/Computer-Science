## HTTP 리퀘스트 메시지를 작성한다

> 사용자가 브라우저에 URL을 입력하면 브라우저가 URL를 해독하여 리퀘스트 메시지를 만든다.
> 

### 탐험 여행은 URL 입력부터 시작한다

- 브라우저의 다양한 기능에 따른 프로토콜과 URL 형식
    
    프로토콜 : 통신 규약
    
    - HTTP : 웹 서버 액세스
        
        `http://[user:password@]웹서버 도메인[:포트번호]/파일의 경로`
        
    - FTP : 파일 다운로드/업로드
        
        `ftp://[user:password@]ftp서버의 도메인[:포트번호]/파일의 경로`
        
    - MAILTO : 메일 송신
        
        `mailto://메일주소`
        
    - FILE : PC 자체의 파일에서 데이터 읽기
        
        `file://[컴퓨터명]/파일의 경로`
        

### 브라우저는 먼저 URL을 해독한다

브라우저는 웹 서버에 보내는 리퀘스트 메시지를 작성하기 위해 URL을 해독한다.

`http: + // + 웹 서버명 + /파일의 경로`

→ 해당 웹 서버에 있는 파일의 경로에 존재하는 파일에 엑세스

### 파일명을 생략한 경우

- `http://www.lab.cyber.co.kr/dir/`
    
    /dir/index.html 또는 /dir/default.html에 엑세스
    
- `http://www.lab.cyber.co.kr/`
    
    /index.html 또는 /default.html에 엑세스
    
- `http://www.lab.cyber.co.kr`
    
    /index.html 또는 /default.html에 엑세스
    
- `http://www.lab.cyber.co.kr/whatisthis`
    
    웹 서버에 ‘whatisthis’라는 파일이 있으면 그 파일에 엑세스
    
    없다면 whatisthis/index.html 또는 whatisthis/default.html에 엑세스
    

### HTTP 기본개념

브라우저는 http 프로토콜을 사용하여 웹 서버에 엑세스

http 프로토콜 : 클라이언트와 서버가 주고 받는 메세지의 내용이나 순서를 정한 것

리퀘스트 메시지 = URI + 메소드

- URI : 엑세스 하는 대상
    
    데이터를 저장한 파일 이름이나 CGI 프로그램의 파일명 등
    
- 메소드 : 어떤 동작을 하고 싶은지
    1. GET : URI로 지정한 정보를 도출. 파일일 경우 파일의 내용을 응답
        
        보통 웹 서버에 엑세스하여 페이지의 데이터를 읽을 때 사용하는 것
        
    2. POST : 클라이언트에서 서버로 데이터 송신
        
        폼에 데이터를 사용해서 웹 서버에 송신하는 경우
        
    3. HEAD : GET와 비슷하지만 HTTP 헤더만 응답하고 데이터를 응답하지 않음
    4. PUT : URI로 지정한 서버의 파일을 치환. 파일이 없는 경우 새로 파일을 작성
    5. DELETE : URI로 지정한 서버의 파일을 삭제

### HTTP 리퀘스트 메시지를 만든다

- 리퀘스트 메시지
    
    ```
    <메소드> <URI> <HTTP버전> -> 리퀘스트 라인
    <필드명>:<필드값> -> 메시지 헤더
    ...
    <공백 행>
    <메시지 본문> -> 메시지 본문
    ```
    
    - 리퀘스트 라인
        
        웹 서버에 어떻게 할 것인지를 전달
        
    - 메시지 헤더
        
        리퀘스트의 부가적인 정보를 나타냄
        
        - 제너럴 헤더 : 리퀘스트와 응답 양쪽 모두 사용하는 필드
            
            Date, Pragma, …
            
        - 리퀘스트 헤더 : 리퀘스트의 부가 정보로 사용되는 필드
            
            Authorization, Host, …
            
        - 응답 헤더 : 응답의 부가 정보로 사용되는 필드
            
            Location, Server, …
            
        - 엔티티 헤더 : 메시지 본문의 부가정보로 사용하는 필드
            
            Allow, Content-type, Etag, … 
            
    - 메시지 본문
        
        클라이언트에서 서버로 송신하는 데이터(GET인 경우 X)
        
    
    예시)
    
    ```
    GET /sample.html HTTP/1.1
    Accept: */*
    ...
    ```
    

### 리퀘스트 메시지를 보내면 응답이 되돌아온다

- 응답 메시지
    
    ```
    <HTTP버전> <스테이터스 코드> <응답 문구> -> 스테이터스 라인
    <필드명>:<필드값> -> 메시지 헤더
    ...
    <공백 행>
    <메시지 본문> -> 메시지 본문
    ```
    
    - 스테이터스 라인
        - 스테이터스 코드 : 프로그램 등에 실행 결과를 알림
            1. 1xx : 처리의 경과 상황 등을 통지
            2. 2xx : 정상 종료
            3. 3xx : 리디렉션 등 다른 조치가 필요함을 나타냄
            4. 4xx : 클라이언트 측 오류
            5. 5xx : 서버 측 오류
        - 응답 문구 : 사람에게 실행 결과를 알림
    - 메시지 본문
        
        서버에서 클라이언트로 송신하는 데이터
        
    
    예시)
    
    ```
    HTTP/1.1 200 OK
    DATE : Wed, 21 Feb 2008 ... 
    ...
    
    <html>
    <head>
    ...
    ```
    
    <aside>
    💡 사진, 영상
    
    리퀘스트 메시지의 URI는 한 개로 결정되어 있으므로, 복수의 파일을 읽을 경우 별도의 리퀘스트 메시지를 보내야한다. 즉, 한 페이지에서 3개의 영상이 존재한다면 총 4번의 리퀘스트 메시지를 웹 서버에 전송해야한다.
    
    </aside>
    

## 웹 서버의 IP주소를 DNS서버에 조회한다

> 웹 서버에 리퀘스트 메시지를 송신할 때는 상대의 IP주소를 OS에 통지해야한다. URL에 쓰여있는 도메인명으로 DNS서버에서 조회하여 IP 주소를 조회한다.
> 

### IP주소의 기본

- TCP/IP
    
    데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 규약
    
    → 인터넷이나 사내 LAN은 TCP/IP의 개념에 기초하여 만들어짐
    
    - 서브넷 : 허브에 몇 대의 PC가 연결되어 있는 것
    - 서브넷이라는 작은 네트워크를 라우터로 접속해서 전체 네트워크가 만들어진다
    - IP주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반
        
        송신측이 메시지를 보내면 서브넷 안에 있는 허브가 가장 가까운 라우터까지 운반하고, 이 라우터가 다음 라우터를 판단하고 운반을 반복하여 최종적으로 상대의 데이터가 도착
        
- IP 주소
    
    IP주소 = 네트워크 번호(서브넷) + 호스트 번호(컴퓨터)
    
    - IP주소는 36비트의 디지털 데이터로, 1바이트(8비트)씩 점으로 구분하여 10진수로 표기
    - 넷마스크 : 어느 부분이 네트워크 번호 또는 호스트 번호인지 표시하기 위한 방법
        
        1 : 네트워크 번호
        
        0 : 호스트 번호
        
        ex) 10.1.2.3/255.255.255.0 → 네트워크 : 10.1.2 / 호스트 : 3
        
    - 특별한 호스트 번호
        
        모두 0 : 서브넷 자체
        
        모두 1 : 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트
        

### 도메인명과 IP주소를 구분하여 사용하는 이유

- 도메인명을 사용하는 이유 : IP주소를 모두 기억하기 어려움
- IP를 사용하는 이유 : 도메인명으로 통신할 경우 도메인명의 최대 크기인 255바이트를 취급해야하므로 라우터 부하 발생. IP는 4바이트

### Socket 라이브러리가 IP주소를 찾는 기능을 제공한다

DNS 서버에 조회한다는 것 = DNS 서버에 조회 메시지를 보내고 응답 메시지를 받는다는 것

- (DNS)리졸버 :  Socket 라이브러리에 속한 프로그램으로, DNS의 원리를 사용하여 IP주소를 조사
    
    Socket 라이브러리 : OS에 포함되어있는 네트워크 기능을 어플리케이션에서 호출하기 위해 부품을 모아놓은 것
    

### 리졸버를 이용하여 DNS 서버를 조회한다

어플리케이션이 Socket라이브러리 프로그램 사용하여 리졸버를 호출

→ 리졸버의 프로그램(gethostbyname)을 통해 리졸버를 호출하면 리졸버가 DNS서버에 조회 메시지를 보내고 DNS 서버에서 온 응답 메시지의 IP주소를 메모리에 저장

```
<메모리 영역> = gethostbyname(도메인명);
```

### 리졸버 내부의 작동

1. 브라우저가 리졸버를 호출하면 제어권이 리졸버의 내부로 넘어감
2. 리졸버에서 DNS서버에 요청하기 위한 메시지를 생성
    
    “www.naver.com”이라는 서버의 IP주소를 가르쳐 주세요~
    
3. OS 프로토콜 스택을 호출
    
    리졸버도 브라우저와 같이 자체적으로 네트워크를 통해 데이터를 송수신하는 기능이 없으므로 OS 프로토콜 스택을 통해 통신
    
4. LAN 어댑터를 통해 메시지가 DNS서버로 향해 송신
5. DNS서버에 액세스 대상의 웹서버가 존재한다면 이에 해당하는 IP주소를 답은 응답 메시지 반송
6. 메시지가 네트워크를 통해 클라이언트로 도착
7. 프로토콜 스택을 경유하여 리졸버로 전달
8. 리졸버가 응답 메시지를 해동한 후 IP주소를 추출하여 부라우저에게 IP주소를 넘겨줌
9. 제어가 브라우저에게 돌아옴

<aside>
💡 **DNS 서버 IP주소**

DNS서버에 메시지를 송신할 경우에도 DNS서버의 IP주소가 필요하다. 이 주소는 컴퓨터에 미리 설정되어 있다. → 네트워크가 바뀔 경우, DNS서버 주소는 자동으로 업데이트 되는 듯

</aside>

## 전 세계의 DNS서버가 연대한다

> DNS서버는 전 세계에 수만 대가 있으며 그것들이 연대하여 IP주소를 조사한다.
> 

### DNS 서버의 기본 동작

DNS서버는 클라이언트에서 조회 메시지를 받고 조회 메시지의 내용에 일치하는 정보를 찾아 응답한다. 조회 메시지에는 이름, 클래스, 타입이 포함된다.

- 이름 : 서버나 메일 배송 목적지와 같은 이름
- 클래스 : 다양한 네트워크의 이용을 식별하기 위한 정보로 인터넷일 경우 ‘IN’
    
    현재는 인터넷 이외의 네트워크는 소멸되었음. 항상 클래스 값은 ‘IN’
    
- 타입 : 이름에 어떤 타입의 정보가 지원되는 지 나타냄. A일 경우 웹 IP주소, MX일 경우 메일 배송 목적지
    
    타입에 다라 클라이언트에 회답하는 정보의 내용이 달라짐
    

ex) `www.lab.cyber.co.kr`이라는 서버의 IP주소를 조사

- 이름 : www.lab.cyber.co.kr
- 클래스 : IN
- 타입 : A

→ 응답 : 192.0.2.226

<aside>
💡 “www”

최초의 웹의 구조를 만들 때 www라는 이름으로 웹 서버를 등록한 것이 많았고 이것이 관례가 된 것 뿐

</aside>

### 도메인의 계층

막대한 수의 서버를 한 대의 DNS서버에 등록할 수 없으므로, 도메인 정보를 분산시켜 다수의 DNS 서버에 등록

- 도메인을 ‘.’으로 구분한 도메인 명으로 계층적인 구조
- 오른쪽에 위치한 것이 상위의 계층
    
    ex) `www.lab.cyber.co.kr`
    
    → ‘kr’도메인 아래의 ‘co’도메인 아래의 ‘cyber’도메인 아래의 ‘lab’도메인 아래의 ‘www’
    

### 담당 DNS 서버를 찾아 IP 주소를 가져온다

수만 대나 되는 DNS를 다 뒤지면서 찾아다닐 순 없다. 하위의 도메인을 담당하는 DNS서버의 IP주소를 그 상위의 DNS서버에 등록하고 상위 DNS서버의 IP주소를 또 그 상위의 DNS 서버에 등록한다.

ex) `lab.glasscom.com`

→ lab.glasscom.com도메인을 담당하는 DNS서버의 IP주소를 glasscom.com도메인을 담당하는 DNS서버에 등록하고 glasscom.com도메인을 담당하는 DNS서버의 IP주소를 com 도메인의 DNS서버에 등록

- 최상위 도메인 : com, kr 등
- 루트 도메인 : 최상위 도메인의 DNS서버의 IP주소가 저장
    
    인터넷에 존재하는 DNS서버에 전부 등록하여 어느 DNS서버에서 루트 도메인에 등록할 수 있음
    

ex) `www.lab.glasscom.com`의 IP주소를 찾는 과정

1. 가장 가까운 DNS서버에 `www.lab.glasscom.com` 서버 정보 조회
2. 가장 가까운 DNS서버에는 해당 서버가 등록되어 있지 않으므로 루트 도메인의 DNS서버에 조회 메시지 전달. 루트 도메인 DNS 서버는 등록되어있는 최상위 도메인인 com서버의 IP주소를 응답
3. 가장 가까운  DNS서버가 com 도메인의 DNS서버에 조회 메시지를 보내고 com 도메인 서버에는 glasscom.com 도메인의 DNS서버 IP주소를 응답

4~5. 위에서 아래로 DNS 서버를 따라가는 동작을 반복하여 원하는 DNS서버(lab.glasscom.com)에 도달. 

해당 DNS서버에서 `www.lab.glasscom.com` 웹서버 IP 응답

1. 가장 가까운 DNS 서버가 `www.lab.glasscom.com` 웹서버 IP주소를 클라이언트에 응답
2. 클라이언트는 웹서버의 IP주소를 알고 액세스할 수 있게됨

### DNS 서버는 캐시기능으로 빠르게 회답할 수 있다

- 현실의 인터넷에서는 한 대의 DNS 서버에 여러개의 도메인의 정보를 등록할 수 있다.
- DNS서버는 한번 조사한 이름을 캐시에 기록하여, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답한다.
    
    정보의 변경 가능성이 있으니 유효기한을 설정하고, 유효기간이 지나면 캐시에서 삭제
    

## 프로토콜 스택에 메시지 송신을 의뢰한다

> 리퀘스트 메시지를 송신하기 위해 OS 프로토콜 스택에 의뢰한다.
> 

### 데이터 송수신 동작의 개요

DNS서버에 IP주소를 조사할 때와 같이 Socket 라이브러리에 들어있는 프로그램 부품들을 결정된 순번대로 호출하여 동작

- 파이프 : 송수신하는 컴퓨터 사이의 데이터 통로
- 소켓 : 파이프의 양 끝에 있는 데이터의 출입구
    
1. 클라이언트 측에서 소켓을 만든다(준비)
2. 서버측의 소켓에 파이프를 연결한다(접속)
3. 데이터를 송수신(송수신)
4. 파이프를 분리하고 소켓을 말소(연결 끊기)

→ 1~4 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다. 어플리케이션은 Socket 라이브러리를 통해 OS 프로토콜 스택에 의뢰하여 파이프를 연결하거나 데이터를 송수신한다.

### 소켓 작성의 단계

```
<디스크럽터> = socket(...);
```

소켓을 생성하고 디스크럽터를 반환

- 디스크럽터 : 소켓을 식별하는 하기 위해 사용하는 것
    
    어플리케이션이 디스크럽터 정보와 함께 접속이나 데이터 송수신 동작을 요청하면 프로토콜 스택이 어느 소켓을 사용하여 접속할 지 판단하여 동작
    

### 파이프를 연결하는 접속 단계

```
connect(<디스크럽터>,<서버IP와 포트번호>,...);
```

어플리케이션이 connect를 호출하여 프로토콜 스택에 의뢰하여 서버측의 소켓과 연결하고 상대와 연결 되면 연결된 상대의 정보를 connect를 호출한 어플리케이션의 소켓에 저장

- 디스크럽터 : 소켓을 만들고 반환된 디스크럽터로, 프로토콜 스택은 디스크럽터를 보고 어느 소켓을 서버측의 소켓과 연결할 지를 판단
- IP 주소 : DNS서버에 조회해서 조사한 서버 IP주소
    
    네트워크에 존재하는 각 컴퓨터를 식별하기 위해 서로 다른 값을 할당한 것으로, IP주소로 알 수 있는 건 네트워크의 어느 컴퓨터인가 하는 것까지임. 서버 측의 소켓을 지정하기 위해 포트번호가 필요.
    
- 포트번호 : IP에 해당하는 컴퓨터의 어느 소켓과 접속할 지 지정
    
    서버측의 포트 번호는 애플리케이션의 종류에 다라 미리 결정된 값을 사용한다. 웹은 80번, 메일은 25번.
    
    → 미리 결정된 포트 번호를 지정하면 번호에 대응하는 서버 애플리케이션의 소켓에 접속할 수 있다! 즉, 브라우저에서 웹 서버에 액세스 할 때의 포트번호는 80번으로 결정되어 있다!
    
    서버측에서는 클라이언트의 소켓을 어떻게 식별함? 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라 할당하고 연결할 때 서버 측에 통지
    

### 메시지를 주고받는 송수신 단계

- 송신
    
    ```
    write(<디스크럽터>,<송신데이터>,...);
    ```
    
    1. 어플리케이션은 송신 데이터(리퀘스트 메시지)를 메모리에 준비
    2. write를 호출할 때 드스크립터와 송신 데이터를 지정
    3. 프로토콜 스택이 송신 데이터를 서버에게  송신
        
        소켓에 연결된 상대가 저장되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대를 판별할 수 있음
        
- 수신
    
    ```
    <수신 데이터 길이> = read(<디스크럽터>,<수신버퍼>,...);
    ```
    
    read를 호출하여 프로토콜 스택에 수신 동작을 의뢰하고 응답 메시지는 수신 버퍼에 저장
    
    - 수신 버퍼 : 수신한 응답 메시지를 저장하기 위한 메모리 영역

### 연결 끊기 단계에서 송수신 종료

```
close(<디스크럽터>);
```

close를 호출하여 소켓까지 연결한 파이프가 분리되고 소켓도 말소

1. HTTP프로토콜에서는 본래 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행
2. 서버측의 연결이 끊어졌다는 소식을 들은 클라이언트는 read로 수신 동작을 의뢰하고 연결이 끊겼다는 사실을 브라우저에게 통지
3. 브라우저도 close를 호출하여 연결 끊음

> HTTP
> 
> 
> HTTP 프로토콜은 HTML 문서나 영상 데이터를 하나하나 별도의 것으로 취급하여 1개의 데이터를 읽을 때마다 `접속 → 리퀘스트 메시지 송신 → 응답 메시지 수신 → 연결끊기` 과정을 반복. 하지만 데이터가 많을 경우 비효율 적이므로 한번 접속한 후 연결을 끊지 않고 송수신하는 방법도 있음.
>
