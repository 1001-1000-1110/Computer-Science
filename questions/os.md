## 프로세스와 스레드 차이는?

프로세스는 운영체제로부터 자원을 할당받아 메모리에 적재되어 실행중인 프로그램을 의미하고, 스레드는 프로세스를 구성하는 실행의 흐름 단위입니다.

## 멀티프로세스와 멀티스레드 차이는?

멀티 프로세스는 여러개의 독립적인 프로세스를 동시에 실행하는 것이며 멀티 스레드는 하나의 프로세스 내에 여러 개의 스레드를 생성하여 동시에 실행하는 것입니다.

멀티 프로세스 환경에서는 프로세스들이 독립적으로 실행되기 때문에 하나의 프로세스에 오류가 발생해도 다른 프로세스들에게 영향을 주지 않습니다. 또한 프로세스들 끼리 자원을 공유하지 않기 때문에 새로운 PCB를 적재하는 과정에서 문맥교환의 오버헤드가 크게 발생합니다.

반면, 멀티 스레드 환경에서는 스레드들끼리 프로세스 내의 자원을 공유하기 때문에 하나의 스레드에 문제가 발생하면 다른 스레드들에게도 영향을 주게됩니다. 또한 멀티스레드는 멀티 프로세스보다 더 작은 메모리 공간을 자치하며 문맥교환의 오버헤드가 적습니다.

## 교착상태란 무엇인가?

교착상태란 두개 이상의 프로세스나 스레드가 각자 가지고 있는 자원을 서로 얻기 위해 기다리고 있는 상황에서 작업을 더 이상 진행하지 못하는 상태를 말합니다.

## 교착 상태의 4가지 조건에 대해 설명해보세요

교착 상태의 4가지 조건에는 상호배제, 점유와 대기, 비선점, 원형 대기가 있습니다.

상호배제는 한 프로세스가 사용하는 자원을 다른 프로세스가 동시에 사용할 수 없다는 조건입니다.

점유와 대기는 자원을 할당받은 상태에서 다른 자원을 할당 받기를 기다린다는 조건입니다.

비선점은 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못한다는 조건입니다.

원형 대기는 프로세스들이 원의 형태로 자원을 대기한다는 조건입니다.

## 교착상태의 해결방법에 대해 설명해보세요

교착 상태를 해결하는 방법에는 예방, 회피, 검출 후 회복이 있습니다.

예방은 교착상태가 발생하지 않도록 발생 조건에 부합하지 않게 자원을 분배하는 방법입니다. 즉 교착상태의 4가지 조건 중 하나를 충족하지 못하게 하는 방법입니다.

회피는 교착 상태가 발생하지 않을 정도로 자원을 할당하다가 교착상태의 위험이 있다면 자원을 할당하지 않는 방법입니다.

검출 후 회복은 자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복하는 방법입니다.

## 메모리 계층에 대해서 예시를 들어 설명해보세요.

메모리 계층은 메모리에 대한 접근 시간과 비용을 최적화 하기 위해 여러 계층 나뉘며 CPU에 가까운 순으로 레지스터, 캐시 메모리, 주 기억장치, 보조기억장치로 구조화 되어있습니다.

레지스터는 CPU 내부에 존재하는 임시 저장장치로 CPU가 가장 빠른 속도로 접근할 수 있습니다. 

캐시 메모리는 CPU와 주 기억장치 사이에 위치하며 레지스터보다 용량이 더 크고 접근 속도가 주 기억장치보다 빠릅니다. CPU가 주 기억장치에 접근하는 시간을 최소화 하기 위해 일부 데이터를 캐시 메모리로 가져와서 사용합니다.

주 기억장치는 캐시메모리보다 용량이 더 크고 접근 속도가 보조기억장치보다 빠릅니다.

보조기억장치는 주 기억장치보다 용량이 더 크지만 접근 시간이 매우 느립니다.

CPU는 실행과정에서 필요한 데이터나 명령어를 레지스터에 저장하여 사용합니다. 추가적인 데이터가 필요할 경우, 캐시 메모리를 먼저 확인합니다. 만약 캐시메모리에 해당 데이터가 없을 경우, 주 기억장치에 접근하여 확인합니다. 만약 주 기억장치에서 추가적으로 데이터를 가져와야하는경우 보조기억장치에서 데이터를 읽어와 주 기억장치에 저장합니다.

## 컴퓨터에 “A”를 입력했을 때, 어떤 과정을 통해 컴퓨터에 “A”라고 출력 되는지 설명해보세요.

컴퓨터에 “A”를 입력했을 때

키보드 컨트롤러는 키 입력 신호를 감지하고 인터럽트(신호)를 발생시킵니다.

CPU는 실행 중인 프로세스를 일시 중단하고 전달된 인터럽트 벡터를 통해 인터럽트 처리 루틴을 실행합니다. 인터럽트 처리 루틴 과정에서 전달된 입력 신호를 해석하여 ”A” 아스키 코드에 해당하는 65번으로 변환합니다.

CPU는 출력하고자하는 장치를 찾아 해당 장치의 입출력 포트로 데이터를 전송합니다. 데이터는 전기 신호로 변환되어 출력 장치로 전달되고 출력장치는 데이터를 해석하여 화면에 “A”라는 문자를 출력합니다.

## 동기와 비동기의 차이는?

동기는 현재 실행중인 작업이 모두 완료 될때까지 기다리는 것을 의미합니다. 작업이 수행되는 동안 다른 작업을 수행할 수 없습니다.

비동기는 현재 실행 중인 작업이 완료될 때까지 기다리지 않고 다음 코드를 실행합니다. 

## Race Condition이란무엇이고 왜 발생하는가?

Race Condition이란 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생한 상황을 의미합니다. 

고급언어는 여러 줄의 저급 언어로 컴파일 되어 실행되는데, 컴퓨터는 이 여러 줄의 저급 언어를 실행하기 때문에 여러 줄의 저급 언어로 변환된 고급 언어 한 줄을 실행하는 도 중 문맥교환이 일어나는 상황에서 발생할 수 있습니다.

## 가상 메모리란 무엇인가요?

가상 메모리란 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술입니다. 가상 메모리를 사용하면 외부 단편화 문제를 최소화 할 수 있으며 물리 메모리보다 더 큰 프로세스를 실행할 수 있게 됩니다. 가장 메모리 기법에는 페이징과 세그멘테이션이 있습니다.

## 페이징이란?

페이징이란 메모리와 프로세스를 일정한 단위로 자르고 이를 메모리에 불연속적으로 할당하는 방법입니다.

일정한 단위로 자른 프로세스와 메모리는 각각 페이지와 프레임이 됩니다. 일정한 단위르 프로세를 불연속적으로 할당하기 때문에 외부 단편화 문제를 해결할 수 있으며 메모리에 적재될 필요가 없는 페이지들을 보조기억장치로 스왑아웃하여 실제 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 됩니다.

하지만 프로세스 크기가 페이지 단위의 배수가 아닐 경우 마지막 페이지에 내부 단편화가 발생하게 되는 단점이 있습니다.

## 세그먼테이션이란?

세그먼테이션이란 프로세스를 서로 다른 크기로 자르고 메모리에 불연속적으로 할당하는 방법입니다.

세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈공간을 찾아 할당합니다. 프로세스가 필요한 메모리 공간 만큼 메모리를 할당해주기 때문에 내부 단편화는 발생하지 않지만, 중간에 메모리를 해제하면 외부 단편화 문제가 발생할 수 있습니다.

## Context Swiching(문맥교환)이란?

CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스의 상태를 저장하고 새 프로세스의 저장된 상태를 적재하는 작업을 의미합니다. 문맥교환 동안 CPU는 아무일도 하지 못하는 오버헤드가 발생합니다.

## 뮤텍스와 세마포어란 무엇이고 이 둘의 차이점은 무엇인가요?

뮤텍스와 세마포어는 상호배제를 위한 동기화 기법입니다. 여기서 상호배제란 한 프로세스가 임계구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다는 원칙입니다.

뮤텍스는 한 프로세스가 임계구역에 진입했을 때 다른 프로세스가 진입하지 못하도록 lock을 해두는 동기화 기법입니다. 

뮤텍스락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식인 반면에, 세마포어는 공유 자원이 여러개 존재하는 상황에서도 적용 가능한 동기화 기법입니다.

## 외부 단편화란 내부 단편화란?

외부 단편화란, 남아 있는 총 메모리 공간이 적재할 프로세스 공간보다 크지만 남아있는 공간이 불연속적이어서 할당할 수 없는 현상을 의미합니다.

내부 단편화란, 메모리를 할당할 때 프로세스가 필요한 크기보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상을 의미합니다.

## 페이지 교체 알고리즘에 따른 페이지 폴트 방식에 대해 설명해보세요

페이지 폴트란 유효비트가 0인 페이지에 접근하려고 할 때 발생하는 인터럽트로, 페이지 폴트가 발생하면 해당 페이지를 보조기억장치에서 가져와서 메모리로 가져와야합니다.

페이지 교체 알고리즘이란, 새로운 페이지를 메모리에 swap in 하기 위해 메모리에 적재되어 있는 페이지 중 어떤 페이지를 swap out 할 지 결정하는 알고리즘입니다. 페이지 교체 알고리즘에는 FIFO 페이지 교체 알고리즘, 최적 페이지 교체 알고리즘, LRU페이지 교체 알고리즘이 있습니다.

FIFO 페이지 교체 알고리즘은 메모리에 가장 먼저 올라온 페이지부터 swap out하는 방식입니다.

최적 페이지 교체 알고리즘은 CPU에 의해 참조될 횟수를 고려하는 페이지 교체 알고리즘으로 가장 낮은 페이지 폴트율을 보장합니다.

LRU 페이지 교체 알고리즘은 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘입니다.

## 운영체제의 운영 기법 중 동시에 프로그램을 수행할 수 있는 CPU를 두 개 이상 두고 각각 그 업무를 분담하여 처리할 수 있는 방식을 의미하는 것은?

→ 멀티프로세싱

## Critical Section(임계영역) 문제를 해결하기 위한 방법을 설명하시오.

임계 영역의 문제를 해결하기 위해서는 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 동기화해야합니다. 동기화 기법에는 뮤텍스락, 세마포어, 모니터가 있습니다.

뮤텍스락은 한 프로세스가 임계구역에 진입했다면 임계구역을 lock을 해두는 기법입니다.

세마포어는 공유자원이 여러개 있는 상황에서도 적용이 가능한 동기화 도구입니다. 사용 가능한 공유자원 개수를 저장하여 프로세스들에게 할당합니다.

모니터는 공유자원와 공유 자원에 접근하기 위한 인터페이스를 묶어 관리하는 기법입니다. 프로세스들은 반드시 인터페이스를 통해서만 공유자원에 접근할 수 있고 모니터 안에 항상 하나의 프로세스만 진입 가능하도록하여 상호배제 동기화를 제공합니다.

## 캐시의 지역성이란 무엇인가?

캐시 메모리에는 CPU가 사용할 법한 대상을 예측하여 저장합니다. 이 때 참조 지역성의 원리를 기반으로 메모리로부터 가져올 데이터를 결정합니다. 참조 지역성에는 시간 지역성과 공간 지역성이 있습니다.

시간 지역성은 CPU가 최근에 접근했던 메모리 공간에 다시 접근하는 경향을 의미합니다.

공간 지역성은 CPU가 접근한 메모리 공간 근처를 접근하는 경향을 의미합니다.

## 하드웨어 스레드와 소프트웨어 스레드에 대해 설명해보세요.

하드웨어 스레드는 하나의 물리적인 코어에 여러 개의 스레드를 동시에 실행시키는 기술입니다.

소프트웨어 스레드란 프로세스를 구성하는 실행의 흐름 단위입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있습니다.

## 패리티비트란? (RAID)

패리티비트란 오류를 검출하고 복구하기 위한 정보입니다. RAID에서는 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고 오류가 있다면 복구합니다.

## ARM이란 무엇인가? ARM의 장점에 대해 설명해보시오

ARM이란 Adavanced RISC Machined의 약자로 CPU의 한 종류 입니다. ARM의 코어는 RICS 방식을 사용합니다.

RICS란 명령어 집합 구조(ISA, CPU가 이해할 수 있는 명령어들의 모음)의 한 종류 입니다. 명령어가 짧고 규격화되어 있으며 1클럭 내외로 명령어를 수행하기 때문에 파이프라이닝에 최적화 되어있습니다. 고정된 명령어이기 때문에 디코딩 속도가 빠릅니다.

## 연속 메모리 할당 알고리즘에 대해 설명해보세요.(3가지)

연속메모리 할당은 비어있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식이며 최초적합, 최적적합, 최악적합이 있습니다.

최초적합은 운영체제가 메모리 내의 빈공간에 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식입니다.

최적적합은 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식입니다.

최악 적합은 운영체제가 빈 공간을 모두 검색해본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식입니다.

## 연속메모리 할당의 단점에 대해 설명해보세요.

연속적으로 할당된 메모리를 해제할 경우 빈공간이 불연속적으로 발생하게 되며, 이 공간보다 큰 프로세스를 할당할 수 없는 상황이 발생할 수 있습니다. (외부 단편화) 또한 연속적으로 메모리를 할당할 경우 물리 메모리보다 큰 프로세스를 할당할 수 없다는 단점이 있습니다. 

## fork()와 vfork()의 차이점은?

fork()와 vfork()는 모두 새로운 자식 프로세스를 생성하는 시스템 콜입니다. fork()와 vfork()는 프로세스를 생성하는 방식에서 차이가 있습니다.

fork()는 부모 프로세스의 복사본을 만들어 완전히 분리된 프로세스를 생성하며 부모프로세스와는 독립적으로 동작합니다.

vfork()는 부모 프로세스와 자식 프로세스가 동일한 메모리 공간을 공유하는 방식으로 프로세스를 생성합니다. fork()와 달리 vfork()는 같은 메모리 공간을 공유하므로 부모 프로세스는 자식 프로세스가 실행을 완료 할 때까지 일시 중단 상태를 유지해야합니다.

## 시스템 콜과 서브루틴의 차이는?

시스템콜은 운영 체제가 제공하는 서비스를 호출하기 위해 사용됩니다. 사용자 모드로 실행하는 프로그램은 시스템 콜을 발생시켜 운영체제에게 요청을 보냅니다. 사용자 모드로 실행중인 CPU는 커널 모드로 전환후 자원에 접근하는 코드를 실행시킬 수 있습니다.

서브루틴은 사용자 모드에서 실행되며 사용자가 직접 작성한 코드를 호출하기 위해서 사용됩니다. 서브 루틴은 호출한 함수 내에서 작업을 수행한 후 호출한 함수로 되돌아갑니다.

## 커널스레드, 유저 스레드, 하드웨어적 스레드의 차이점에 대해 설명해보세요.

하드웨어적 스레드는 하나의 물리적인 코어에 여러 개의 스레드를 동시에 실행시키는 기술입니다.

커널 스레드는 운영체제 커널에서 생성되고 관리되는 스레드입니다.커널 스레드는 CPU에서 직접 스케줄링되며 하드웨어와 관련된 작업을 수행합니다.

유저 스레드는 프로그램 레벨에서 생성되는 스레드 입니다. 유저 스레드가 CPU에서 실행되기 위해서는 반드시 커널 스레드와 연결되어야합니다.
